<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Multi-Interval TradingView Chart with Indicators</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />

  <style>
    :root {
      --bg: #0e1116;
      --panel: #121722;
      --text: #e5e7eb;
      --muted: #9aa4b2;
      --accent: #3b82f6;
      --border: #253043;
      --shadow: rgba(0,0,0,0.3);
    }
    .light {
      --bg: #f6f7fb;
      --panel: #ffffff;
      --text: #111827;
      --muted: #6b7280;
      --accent: #2563eb;
      --border: #e5e7eb;
      --shadow: rgba(0,0,0,0.08);
    }

    html, body {
      height: 100%;
      margin: 0;
      background: var(--bg);
      color: var(--text);
      font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji", "Segoe UI Emoji";
    }

    .app {
      display: flex;
      flex-direction: column;
      height: 100%;
      width: 100%;
    }

    .toolbar {
      display: flex;
      gap: 12px;
      align-items: center;
      padding: 10px 12px;
      background: var(--panel);
      border-bottom: 1px solid var(--border);
      box-shadow: 0 2px 8px var(--shadow);
      flex-wrap: wrap;
    }

    .toolbar .title {
      font-weight: 600;
      margin-right: auto;
    }

    .btn {
      display: inline-flex;
      align-items: center;
      gap: 8px;
      padding: 8px 12px;
      border-radius: 8px;
      border: 1px solid var(--border);
      background: transparent;
      color: var(--text);
      cursor: pointer;
      transition: background 0.2s, border-color 0.2s, color 0.2s;
      user-select: none;
    }
    .btn:hover {
      background: rgba(59,130,246,0.08);
      border-color: var(--accent);
    }
    .btn.active {
      background: var(--accent);
      color: white;
      border-color: var(--accent);
    }

    .select {
      background: transparent;
      color: var(--text);
      border: 1px solid var(--border);
      border-radius: 8px;
      padding: 8px 12px;
    }

    .container {
      position: relative;
      flex: 1;
      width: 100%;
      min-height: 0;
    }

    #chart {
      position: absolute;
      inset: 0;
    }

    .overlay {
      position: absolute;
      right: 12px;
      bottom: 12px;
      display: flex;
      flex-direction: column;
      gap: 8px;
      z-index: 10;
    }

    .pill {
      background: var(--panel);
      color: var(--text);
      border: 1px solid var(--border);
      border-radius: 9999px;
      padding: 6px 10px;
      font-size: 12px;
      opacity: 0.9;
    }

    .legend {
      position: absolute;
      left: 12px;
      bottom: 12px;
      display: flex;
      flex-direction: column;
      gap: 6px;
      z-index: 10;
    }

    .legend .row {
      display: flex;
      align-items: center;
      gap: 8px;
      background: var(--panel);
      border: 1px solid var(--border);
      border-radius: 8px;
      padding: 6px 10px;
      font-size: 12px;
    }
    .dot {
      width: 10px;
      height: 10px;
      border-radius: 2px;
    }

    .panel {
      background: var(--panel);
      border: 1px solid var(--border);
      border-radius: 10px;
      padding: 10px;
    }

    /* Mobile first */
    .toolbar {
      gap: 8px;
    }
    .intervals {
      display: flex;
      gap: 6px;
      overflow-x: auto;
      padding-bottom: 4px;
      scrollbar-width: none;
    }
    .intervals::-webkit-scrollbar {
      display: none;
    }

    /* Desktop overrides */
    @media (min-width: 768px) {
      .toolbar {
        gap: 12px;
      }
      .intervals {
        gap: 8px;
      }
    }
  </style>

  <script type="importmap">
  {
    "imports": {
      "lightweight-charts": "https://cdn.jsdelivr.net/npm/lightweight-charts@4.2.3/dist/lightweight-charts.esm.production.js"
    }
  }
  </script>
</head>
<body>
  <div class="app light" id="appRoot">
    <div class="toolbar">
      <div class="title">Multi-Interval Chart</div>

      <div class="intervals">
        <button class="btn" data-int="1">M1</button>
        <button class="btn" data-int="5">M5</button>
        <button class="btn" data-int="15">M15</button>
        <button class="btn" data-int="60">H1</button>
        <button class="btn" data-int="240">H4</button>
        <button class="btn" data-int="D">D1</button>
        <button class="btn" data-int="W">W1</button>
        <button class="btn" data-int="M">MN</button>
        <button class="btn" data-int="Y">Y1</button>
      </div>

      <button class="btn" id="themeToggle" title="Toggle Theme">
        Toggle Theme
      </button>

      <div class="panel" style="display:flex; gap:8px; align-items:center;">
        <label for="rsiPeriod">RSI</label>
        <input id="rsiPeriod" class="select" type="number" min="2" max="100" value="14" style="width:70px;">
        <label for="stochK">Stoch K</label>
        <input id="stochK" class="select" type="number" min="2" max="100" value="14" style="width:70px;">
        <label for="stochD">D</label>
        <input id="stochD" class="select" type="number" min="1" max="100" value="3" style="width:60px;">
        <label for="stochS">S</label>
        <input id="stochS" class="select" type="number" min="1" max="100" value="3" style="width:60px;">
        <button class="btn" id="applyIndicators">Apply</button>
      </div>
    </div>

    <div class="container">
      <div id="chart"></div>

      <div class="legend" id="legend">
        <div class="row"><div class="dot" id="dotMain"></div><div>Main</div></div>
        <div class="row"><div class="dot" id="dotHTF1"></div><div>HTF 1</div></div>
        <div class="row"><div class="dot" id="dotHTF2"></div><div>HTF 2</div></div>
        <div class="row"><div class="dot" id="dotHTF3"></div><div>HTF 3</div></div>
      </div>

      <div class="overlay">
        <div class="pill" id="infoInterval">Interval: D1</div>
        <div class="pill" id="infoTheme">Theme: Light</div>
      </div>
    </div>
  </div>

  <script type="module">
    import { createChart, CrosshairMode } from "lightweight-charts";

    // Tailwind-like utility via classes already in CSS; we will programmatically style colors.

    // Theme handling
    const appRoot = document.getElementById('appRoot');
    const themeToggle = document.getElementById('themeToggle');
    const infoTheme = document.getElementById('infoTheme');

    let isDark = false;
    function applyTheme() {
      if (isDark) {
        appRoot.classList.remove('light');
      } else {
        appRoot.classList.add('light');
      }
      infoTheme.textContent = 'Theme: ' + (isDark ? 'Dark' : 'Light');
      applyChartTheme();
    }
    themeToggle.addEventListener('click', () => {
      isDark = !isDark;
      applyTheme();
    });

    // Create chart
    const chartContainer = document.getElementById('chart');

    function chartColors() {
      if (isDark) {
        return {
          background: '#0e1116',
          grid: '#1f2937',
          text: '#cbd5e1',
          up: '#22c55e',
          down: '#ef4444',
          vol: '#64748b'
        };
      } else {
        return {
          background: '#f6f7fb',
          grid: '#e5e7eb',
          text: '#1f2937',
          up: '#16a34a',
          down: '#dc2626',
          vol: '#94a3b8'
        };
      }
    }

    let chart = createChart(chartContainer, {
      autoSize: true,
      layout: {
        background: { color: chartColors().background },
        textColor: chartColors().text,
      },
      grid: {
        vertLines: { color: chartColors().grid },
        horzLines: { color: chartColors().grid },
      },
      crosshair: { mode: CrosshairMode.Normal },
      timeScale: { timeVisible: true, secondsVisible: false, rightBarStaysOnScroll: true, borderColor: chartColors().grid },
      rightPriceScale: { borderColor: chartColors().grid },
      handleScroll: { mouseWheel: true, pressedMouseMove: true, horzTouchDrag: true, vertTouchDrag: true },
      handleScale: { mouseWheel: true, pinch: true, axisPressedMouseMove: true }
    });

    // Panels: We'll simulate top (RSI) and bottom (Stoch) panes using separate price scales and overlay lines with baselines.
    // lightweight-charts doesn't support draggable pane dividers natively, so we implement a custom splitter layered UI.

    // Series
    const mainCandles = chart.addCandlestickSeries({
      upColor: chartColors().up, downColor: chartColors().down,
      borderUpColor: chartColors().up, borderDownColor: chartColors().down,
      wickUpColor: chartColors().up, wickDownColor: chartColors().down
    });

    // Higher timeframe transparent candles (three degrees)
    const htf1 = chart.addCandlestickSeries({
      priceScaleId: 'right',
      upColor: 'rgba(34,197,94,0.35)',
      downColor: 'rgba(239,68,68,0.35)',
      wickUpColor: 'rgba(34,197,94,0.25)',
      wickDownColor: 'rgba(239,68,68,0.25)',
      borderUpColor: 'rgba(34,197,94,0.35)',
      borderDownColor: 'rgba(239,68,68,0.35)'
    });
    const htf2 = chart.addCandlestickSeries({
      priceScaleId: 'right',
      upColor: 'rgba(34,197,94,0.22)',
      downColor: 'rgba(239,68,68,0.22)',
      wickUpColor: 'rgba(34,197,94,0.15)',
      wickDownColor: 'rgba(239,68,68,0.15)',
      borderUpColor: 'rgba(34,197,94,0.22)',
      borderDownColor: 'rgba(239,68,68,0.22)'
    });
    const htf3 = chart.addCandlestickSeries({
      priceScaleId: 'right',
      upColor: 'rgba(34,197,94,0.12)',
      downColor: 'rgba(239,68,68,0.12)',
      wickUpColor: 'rgba(34,197,94,0.08)',
      wickDownColor: 'rgba(239,68,68,0.08)',
      borderUpColor: 'rgba(34,197,94,0.12)',
      borderDownColor: 'rgba(239,68,68,0.12)'
    });

    // RSI and Stochastic series - place them on separate overlayed panes by mapping values to custom price scales
    const RSI_SCALE = 'rsi';
    const STOCH_SCALE = 'stoch';

    chart.priceScale(RSI_SCALE, {
      scaleMargins: { top: 0.02, bottom: 0.8 }, // top pane 1/8
      borderColor: chartColors().grid
    });
    chart.priceScale(STOCH_SCALE, {
      scaleMargins: { top: 0.8, bottom: 0.02 }, // bottom pane 1/8
      borderColor: chartColors().grid
    });
    chart.priceScale('right', {
      scaleMargins: { top: 0.13, bottom: 0.13 } // main chart occupies 3/4 (1 - 1/8 - 1/8)
    });

    const rsiLine = chart.addLineSeries({
      priceScaleId: RSI_SCALE,
      color: '#8b5cf6',
      lineWidth: 2
    });
    const rsiUpper = chart.addLineSeries({ priceScaleId: RSI_SCALE, color: 'rgba(139,92,246,0.3)', lineWidth: 1 });
    const rsiLower = chart.addLineSeries({ priceScaleId: RSI_SCALE, color: 'rgba(139,92,246,0.3)', lineWidth: 1 });

    const stochKLine = chart.addLineSeries({
      priceScaleId: STOCH_SCALE,
      color: '#06b6d4',
      lineWidth: 2
    });
    const stochDLine = chart.addLineSeries({
      priceScaleId: STOCH_SCALE,
      color: '#f59e0b',
      lineWidth: 2
    });
    const stochUpper = chart.addLineSeries({ priceScaleId: STOCH_SCALE, color: 'rgba(245,158,11,0.25)', lineWidth: 1 });
    const stochLower = chart.addLineSeries({ priceScaleId: STOCH_SCALE, color: 'rgba(245,158,11,0.25)', lineWidth: 1 });

    // Legend color dots
    const dotMain = document.getElementById('dotMain');
    const dotHTF1 = document.getElementById('dotHTF1');
    const dotHTF2 = document.getElementById('dotHTF2');
    const dotHTF3 = document.getElementById('dotHTF3');
    dotMain.style.background = isDark ? '#22c55e' : '#16a34a';
    dotHTF1.style.background = 'rgba(59,130,246,0.35)';
    dotHTF2.style.background = 'rgba(59,130,246,0.22)';
    dotHTF3.style.background = 'rgba(59,130,246,0.12)';

    // Interval mapping
    const intervals = [
      { key: '1', label: 'M1', seconds: 60 },
      { key: '5', label: 'M5', seconds: 300 },
      { key: '15', label: 'M15', seconds: 900 },
      { key: '60', label: 'H1', seconds: 3600 },
      { key: '240', label: 'H4', seconds: 14400 },
      { key: 'D', label: 'D1', seconds: 86400 },
      { key: 'W', label: 'W1', seconds: 604800 },
      { key: 'M', label: 'MN', seconds: 2629800 }, // approx month
      { key: 'Y', label: 'Y1', seconds: 31557600 } // approx year
    ];
    const intByKey = Object.fromEntries(intervals.map(i => [i.key, i]));
    const infoInterval = document.getElementById('infoInterval');

    function higherIntervals(key) {
      // Compute up to three higher TFs. Special rule: monthly->yearly (second-degree), all lower show up to third-degree, highest Y1.
      const order = ['1','5','15','60','240','D','W','M','Y'];
      const idx = order.indexOf(key);
      const out = [];
      for (let i=1; i<=3; i++) {
        const k = order[Math.min(idx + i, order.length - 1)];
        if (!k) break;
        if (k === key) continue;
        out.push(k);
        if (k === 'Y') break;
      }
      return out;
    }

    // Synthetic OHLCV data generator (no external assets)
    function generateData(startTimeSec, bars, basePrice, volatilityPct, stepSec) {
      let t = startTimeSec;
      const data = [];
      let price = basePrice;
      let volBase = 1000;
      for (let i=0; i<bars; i++) {
        const drift = Math.sin(i / 50) * volatilityPct * basePrice;
        const noise = (Math.random() - 0.5) * volatilityPct * basePrice * 0.6;
        const open = price;
        let close = Math.max(1, open + drift*0.02 + noise);
        const high = Math.max(open, close) + Math.abs(noise) * 0.8;
        const low  = Math.min(open, close) - Math.abs(noise) * 0.8;
        const volume = Math.max(10, Math.round(volBase + (Math.sin(i/15)*200) + Math.random()*300));
        data.push({ time: t, open, high, low, close, volume });
        price = close;
        t += stepSec;
      }
      return data;
    }

    // Aggregate to higher timeframe
    function aggregate(data, stepSec, aggSec) {
      const bucket = new Map();
      for (const d of data) {
        const t0 = Math.floor(d.time / aggSec) * aggSec;
        const key = t0;
        if (!bucket.has(key)) {
          bucket.set(key, { time: t0, open: d.open, high: d.high, low: d.low, close: d.close, volume: d.volume });
        } else {
          const b = bucket.get(key);
          b.high = Math.max(b.high, d.high);
          b.low = Math.min(b.low, d.low);
          b.close = d.close;
          b.volume += d.volume;
        }
      }
      return Array.from(bucket.values()).sort((a,b)=>a.time-b.time);
    }

    // Indicators
    function SMA(values, period) {
      const out = new Array(values.length).fill(null);
      let sum = 0;
      for (let i=0; i<values.length; i++) {
        sum += values[i];
        if (i >= period) sum -= values[i - period];
        if (i >= period - 1) out[i] = sum / period;
      }
      return out;
    }

    function RSI(close, period=14) {
      const out = new Array(close.length).fill(null);
      let gains = 0, losses = 0;
      for (let i=1; i<close.length; i++) {
        const ch = close[i] - close[i-1];
        const gain = Math.max(ch, 0);
        const loss = Math.max(-ch, 0);
        if (i <= period) {
          gains += gain;
          losses += loss;
          if (i === period) {
            let rs = (gains/period) / (losses/period || 1e-10);
            out[i] = 100 - 100 / (1 + rs);
          }
        } else {
          gains = (gains * (period - 1) + gain) / period;
          losses = (losses * (period - 1) + loss) / period;
          let rs = gains / (losses || 1e-10);
          out[i] = 100 - 100 / (1 + rs);
        }
      }
      return out;
    }

    function Stochastic(high, low, close, kPeriod=14, dPeriod=3, smooth=3) {
      const kRaw = new Array(close.length).fill(null);
      for (let i=0; i<close.length; i++) {
        if (i < kPeriod - 1) continue;
        let h = -Infinity, l = Infinity;
        for (let j=i-kPeriod+1; j<=i; j++) {
          h = Math.max(h, high[j]);
          l = Math.min(l, low[j]);
        }
        const denom = (h - l) || 1e-10;
        kRaw[i] = ((close[i] - l) / denom) * 100;
      }
      const kSmooth = SMA(kRaw.map(v => v ?? 0), smooth);
      const dLine = SMA(kSmooth.map(v => v ?? 0), dPeriod);
      const outK = kSmooth.map((v,i) => (i < kPeriod - 1 + smooth - 1 ? null : v));
      const outD = dLine.map((v,i) => (i < kPeriod - 1 + smooth - 1 + dPeriod - 1 ? null : v));
      return { k: outK, d: outD };
    }

    function applyChartTheme() {
      const c = chartColors();
      chart.applyOptions({
        layout: { background: { color: c.background }, textColor: c.text },
        grid: { vertLines: { color: c.grid }, horzLines: { color: c.grid } },
        timeScale: { borderColor: c.grid },
        rightPriceScale: { borderColor: c.grid }
      });
      dotMain.style.background = isDark ? '#22c55e' : '#16a34a';
    }

    // Interval controls
    const intervalButtons = Array.from(document.querySelectorAll('.intervals .btn'));
    let currentIntervalKey = 'D';

    function setActiveIntervalButton(key) {
      intervalButtons.forEach(b => {
        if (b.dataset.int === key) b.classList.add('active');
        else b.classList.remove('active');
      });
      infoInterval.textContent = 'Interval: ' + intByKey[key].label;
    }

    intervalButtons.forEach(btn => {
      btn.addEventListener('click', () => {
        const key = btn.dataset.int;
        if (key === currentIntervalKey) return;
        currentIntervalKey = key;
        setActiveIntervalButton(key);
        refreshDataForInterval();
      });
    });

    // Generate base minute data and then aggregate as needed on-the-fly
    const nowSec = Math.floor(Date.now() / 1000);
    const BASE_STEP = 60; // 1-minute base
    const baseData = generateData(nowSec - 400*BASE_STEP, 400, 20000, 0.0025, BASE_STEP);

    function seriesSetDataFromCandles(series, candles) {
      series.setData(candles.map(c => ({ time: c.time, open: c.open, high: c.high, low: c.low, close: c.close })));
    }

    function computeForInterval(key) {
      const main = intByKey[key];
      // Compute main candles
      let mainCandlesData;
      if (key === '1') mainCandlesData = baseData;
      else if (key === '5') mainCandlesData = aggregate(baseData, 60, 300);
      else if (key === '15') mainCandlesData = aggregate(baseData, 60, 900);
      else if (key === '60') mainCandlesData = aggregate(baseData, 60, 3600);
      else if (key === '240') mainCandlesData = aggregate(baseData, 60, 14400);
      else if (key === 'D') mainCandlesData = aggregate(baseData, 60, 86400);
      else if (key === 'W') mainCandlesData = aggregate(baseData, 60, 604800);
      else if (key === 'M') mainCandlesData = aggregate(baseData, 60, 2629800);
      else if (key === 'Y') mainCandlesData = aggregate(baseData, 60, 31557600);

      const htfKeys = higherIntervals(key);
      const htfData = htfKeys.map(k => {
        const step = intByKey[k].seconds;
        return aggregate(baseData, 60, step);
      });

      return { mainCandlesData, htfData, htfKeys };
    }

    function updateIndicators(candles) {
      const close = candles.map(c => c.close);
      const high = candles.map(c => c.high);
      const low = candles.map(c => c.low);
      const times = candles.map(c => c.time);

      const rsiPeriod = parseInt(document.getElementById('rsiPeriod').value) || 14;
      const rsi = RSI(close, rsiPeriod);
      const rsiData = times.map((t,i) => rsi[i] == null ? { time: t, value: null } : { time: t, value: rsi[i] });
      rsiLine.setData(rsiData);
      // Reference lines 70/30
      rsiUpper.setData(times.map(t => ({ time: t, value: 70 })));
      rsiLower.setData(times.map(t => ({ time: t, value: 30 })));

      const kPeriod = parseInt(document.getElementById('stochK').value) || 14;
      const dPeriod = parseInt(document.getElementById('stochD').value) || 3;
      const sPeriod = parseInt(document.getElementById('stochS').value) || 3;
      const { k, d } = Stochastic(high, low, close, kPeriod, dPeriod, sPeriod);
      const kData = times.map((t,i) => k[i] == null ? { time: t, value: null } : { time: t, value: k[i] });
      const dData = times.map((t,i) => d[i] == null ? { time: t, value: null } : { time: t, value: d[i] });
      stochKLine.setData(kData);
      stochDLine.setData(dData);
      // Reference lines 80/20
      stochUpper.setData(times.map(t => ({ time: t, value: 80 })));
      stochLower.setData(times.map(t => ({ time: t, value: 20 })));
    }

    function refreshDataForInterval() {
      const { mainCandlesData, htfData, htfKeys } = computeForInterval(currentIntervalKey);
      seriesSetDataFromCandles(mainCandles, mainCandlesData);
      seriesSetDataFromCandles(htf1, htfData[0] ?? []);
      seriesSetDataFromCandles(htf2, htfData[1] ?? []);
      seriesSetDataFromCandles(htf3, htfData[2] ?? []);

      // Update labels for legend visibility
      document.querySelector('#legend .row:nth-child(2)').style.display = htfData[0] ? 'flex' : 'none';
      document.querySelector('#legend .row:nth-child(3)').style.display = htfData[1] ? 'flex' : 'none';
      document.querySelector('#legend .row:nth-child(4)').style.display = htfData[2] ? 'flex' : 'none';

      updateIndicators(mainCandlesData);
    }

    // Apply indicator settings
    document.getElementById('applyIndicators').addEventListener('click', () => {
      const { mainCandlesData } = computeForInterval(currentIntervalKey);
      updateIndicators(mainCandlesData);
    });

    // Draggable panel heights via scaleMargins manipulation
    // We'll capture mouse drag on invisible gutters near top and bottom of main area.
    let draggingTop = false;
    let draggingBottom = false;

    function setPaneFractions(rsiFrac, stochFrac) {
      // Clamp
      rsiFrac = Math.max(0.08, Math.min(0.5, rsiFrac));
      stochFrac = Math.max(0.08, Math.min(0.5, stochFrac));
      const mainFrac = Math.max(0.2, 1 - rsiFrac - stochFrac);

      chart.priceScale(RSI_SCALE).applyOptions({ scaleMargins: { top: 0.02, bottom: 1 - rsiFrac } });
      chart.priceScale('right').applyOptions({ scaleMargins: { top: rsiFrac + 0.02, bottom: stochFrac + 0.02 } });
      chart.priceScale(STOCH_SCALE).applyOptions({ scaleMargins: { top: 1 - stochFrac, bottom: 0.02 } });
    }

    // Default: 1/8 each
    let rsiFrac = 1/8;
    let stochFrac = 1/8;
    setPaneFractions(rsiFrac, stochFrac);

    // Create draggable overlays
    const topDivider = document.createElement('div');
    topDivider.style.position = 'absolute';
    topDivider.style.left = '0';
    topDivider.style.right = '0';
    topDivider.style.height = '8px';
    topDivider.style.cursor = 'row-resize';
    topDivider.style.zIndex = '20';

    const bottomDivider = topDivider.cloneNode(true);

    chart.timeScale().subscribeVisibleTimeRangeChange(() => {
      // no-op, but forces layout events
    });

    function layoutDividers() {
      const { height } = chartContainer.getBoundingClientRect();
      const topY = Math.round(height * rsiFrac) + 6;
      const bottomY = Math.round(height * (1 - stochFrac)) - 6;
      topDivider.style.top = (topY - 4) + 'px';
      bottomDivider.style.top = (bottomY - 4) + 'px';
    }
    window.addEventListener('resize', layoutDividers);
    chartContainer.appendChild(topDivider);
    chartContainer.appendChild(bottomDivider);
    layoutDividers();

    function onMouseDownFactory(which) {
      return (e) => {
        e.preventDefault();
        draggingTop = which === 'top';
        draggingBottom = which === 'bottom';
        document.body.style.userSelect = 'none';
      };
    }
    function onMouseMove(e) {
      if (!draggingTop && !draggingBottom) return;
      const rect = chartContainer.getBoundingClientRect();
      const y = e.clientY - rect.top;
      const h = rect.height;
      if (draggingTop) {
        rsiFrac = Math.max(0.08, Math.min(0.5, y / h));
      } else if (draggingBottom) {
        stochFrac = Math.max(0.08, Math.min(0.5, 1 - (y / h)));
      }
      setPaneFractions(rsiFrac, stochFrac);
      layoutDividers();
    }
    function onMouseUp() {
      draggingTop = draggingBottom = false;
      document.body.style.userSelect = '';
    }
    topDivider.addEventListener('mousedown', onMouseDownFactory('top'));
    bottomDivider.addEventListener('mousedown', onMouseDownFactory('bottom'));
    window.addEventListener('mousemove', onMouseMove);
    window.addEventListener('mouseup', onMouseUp);
    // Touch support
    topDivider.addEventListener('touchstart', (e)=>{ onMouseDownFactory('top')(e.touches[0]); }, {passive:true});
    bottomDivider.addEventListener('touchstart', (e)=>{ onMouseDownFactory('bottom')(e.touches[0]); }, {passive:true});
    window.addEventListener('touchmove', (e)=>{ onMouseMove(e.touches[0]); }, {passive:true});
    window.addEventListener('touchend', onMouseUp);

    // Initialize
    setActiveIntervalButton(currentIntervalKey);
    applyTheme();
    refreshDataForInterval();

  </script>
</body>
</html>
