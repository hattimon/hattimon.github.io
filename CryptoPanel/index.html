<!DOCTYPE html>
<html lang="pl">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
  <title>Krypto Dashboard – Świece z darmowego API + tryb offline</title>
  <style>
    :root{
      --bg:#0b1020;
      --panel:#101832;
      --text:#e7ecff;
      --muted:#b7c3ff;
      --accent:#6aa9ff;
      --good:#27d980;
      --bad:#ff5c7a;
      --warn:#ffcc66;
      --border:rgba(255,255,255,0.08);
      --shadow: 0 10px 30px rgba(0,0,0,0.35);
      --radius:14px;
    }
    *{box-sizing:border-box}
    html,body,#root{height:100%}
    body{
      margin:0;
      font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Inter, "Helvetica Neue", Arial;
      color:var(--text);
      background:
        radial-gradient(60vw 60vw at 10% -10%, rgba(106,169,255,0.15), transparent 60%),
        radial-gradient(50vw 50vw at 110% 10%, rgba(255,92,122,0.12), transparent 60%),
        linear-gradient(180deg, #090d1a, #0b1020 30%, #0b1020 100%);
      overflow:auto;
    }
    header{
      display:flex;align-items:center;justify-content:space-between;
      padding:14px 16px;border-bottom:1px solid var(--border);
      backdrop-filter: blur(8px);
      position:sticky;top:0;z-index:50;
      background: linear-gradient(180deg, rgba(16,24,50,0.85), rgba(16,24,50,0.55));
    }
    .brand{display:flex;gap:12px;align-items:center}
    .logo{
      width:34px;height:34px;border-radius:10px;
      background: conic-gradient(from 220deg, #6aa9ff, #8b6aff, #ff5c7a, #6aa9ff);
      box-shadow: inset 0 0 20px rgba(255,255,255,0.25), 0 8px 20px rgba(106,169,255,0.35);
      position:relative;
    }
    .logo:after{content:"";position:absolute;inset:5px;border-radius:8px;background:var(--panel);box-shadow: inset 0 0 12px rgba(0,0,0,0.45)}
    .muted{color:var(--muted)}
    .row{
      display:grid;grid-template-columns: 320px 1fr;gap:18px;
      padding:18px clamp(12px, 3vw, 22px) 22px clamp(12px, 3vw, 22px);
      align-items:start;
    }
    .panel{
      background: linear-gradient(180deg, rgba(16,24,50,0.75), rgba(16,24,50,0.5));
      border:1px solid var(--border);border-radius:var(--radius);box-shadow: var(--shadow);padding:14px;
    }
    .btn{
      background:linear-gradient(180deg, #6aa9ff, #3b7be6);
      color:#071024;border:none;padding:10px 12px;border-radius:10px;font-weight:700;
      cursor:pointer;box-shadow: 0 6px 18px rgba(106,169,255,0.35);
      transition: transform .08s ease, box-shadow .2s ease; font-size:13px;
    }
    .btn.small{padding:6px 8px;font-size:12px;border-radius:8px}
    .btn.alt{
      background:linear-gradient(180deg, #1e2b55, #142043);
      color:var(--text);border:1px solid var(--border); box-shadow:none; font-weight:600;
    }
    .input, select{
      background:linear-gradient(180deg, #0c1430, #0b132a);
      border:1px solid var(--border);color:var(--text);
      padding:10px;border-radius:10px;outline:none;font-size:13px;
    }
    aside{display:flex;flex-direction:column;gap:14px;position:sticky;top:70px}
    .canvas{
      position:relative;border-radius:12px;border:1px solid var(--border);
      background: linear-gradient(180deg, rgba(24,36,80,0.35), rgba(12,18,40,0.45));
      min-height: 520px;overflow:auto;
    }
    .tile{
      position:absolute;
      background: #0b1330;
      border:1px solid var(--border);
      border-radius:6px;
      box-shadow: var(--shadow);
      overflow:hidden;
      display:flex;flex-direction:column;
      touch-action:none;
      pointer-events:auto;
    }
    .tile .toolbar{
      display:flex;align-items:center;justify-content:space-between;gap:6px;
      padding:6px 8px;border-bottom:1px solid var(--border);
      background:#0c1230;
      cursor: default;
      user-select:none;
    }
    .grabber{display:flex;align-items:center;gap:6px}
    .grab-handle{
      width:14px;height:14px;border-radius:3px;border:1px dashed rgba(255,255,255,0.25);
      background:linear-gradient(180deg, rgba(255,255,255,0.06), rgba(255,255,255,0.02));
      cursor: grab;
    }
    .title{font-size:12px;color:var(--muted)}
    .actions{display:flex;gap:6px;flex-wrap:wrap}
    .content{position:relative;flex:1;min-height:140px}
    .resizer{
      position:absolute;right:6px;bottom:6px;width:14px;height:14px;border-radius:4px;border:1px solid var(--border);
      background:linear-gradient(135deg, rgba(106,169,255,0.45), rgba(106,169,255,0.15));
      cursor:nwse-resize;opacity:0.85;
    }
    @media (max-width: 1100px){
      .row{grid-template-columns: 1fr;gap:14px}
      .canvas{min-height:420px}
      header{gap:10px;flex-wrap:wrap}
    }
    .table{width:100%;border-collapse:separate;border-spacing:0;overflow:hidden;border-radius:12px;border:1px solid var(--border)}
    .table th, .table td{padding:10px;border-bottom:1px solid var(--border);font-size:13px;text-align:left}
    .table th{color:var(--muted);font-weight:600;background:rgba(16,24,50,0.55);backdrop-filter: blur(6px)}
    /* Offline/online canvas styles */
    .offwrap,.onwrap{position:absolute;inset:0;display:grid;grid-template-rows:auto 1fr}
    .offhdr,.onhdr{display:flex;align-items:center;gap:8px;padding:6px 8px;border-bottom:1px solid var(--border);background:#0b122a}
    .badge{font-size:11px;padding:2px 6px;border-radius:6px;background:#1a2b55;color:#9ec1ff;border:1px solid rgba(106,169,255,0.35)}
    canvas.chart{width:100%;height:100%;display:block;background:linear-gradient(180deg,#0b1128,#0a1024)}
    .legend{position:absolute;top:8px;right:8px;background:rgba(0,0,0,0.35);padding:6px 8px;border-radius:8px;font-size:12px;color:#cfe0ff;border:1px solid rgba(255,255,255,0.1)}
    .status{font-size:12px;color:#9ec1ff}
  </style>
  <script type="importmap">
    {
      "imports": {
        "preact": "https://cdn.jsdelivr.net/npm/preact@10.19.6/dist/preact.module.js",
        "htm": "https://cdn.jsdelivr.net/npm/htm@3.1.1/dist/htm.module.js",
        "uuid": "https://cdn.jsdelivr.net/npm/uuid@9.0.1/dist/esm-browser/index.js"
      }
    }
  </script>
</head>
<body>
  <div id="root"></div>

  <script type="module">
    import { h, render } from "preact";
    import htm from "htm";
    import { v4 as uuidv4 } from "uuid";
    const html = htm.bind(h);

    // Strategia danych świecowych:
    // 1) Gdy online – pobieramy świece z darmowego API Binance Futures klines (bardzo długa historia, brak klucza).
    // 2) Gdy offline lub błąd – generujemy syntetyczne świece lokalnie.
    //
    // Dlaczego Binance:
    // - Darmowe i bez klucza API
    // - Długie historie (limit 1500 na request; można "stronicować" po timestampach)
    // - Stabilne endpointy
    // Uwaga: Cross-origin działa w przeglądarce, brak potrzeby serwera.

    const INTERVALS = {
      "1m": "1m", "5m": "5m", "15m": "15m", "1h": "1h", "4h": "4h", "1d": "1d"
    };

    function tvToBinanceSymbol(sym){ // "BINANCE:BTCUSDT" -> "BTCUSDT"
      const parts = String(sym).split(":");
      const pair = parts[1] || parts[0] || "BTCUSDT";
      return pair.replace("/", "");
    }

    async function fetchBinanceKlines(symbol="BTCUSDT", interval="1h", limit=500, startTime){
      const params = new URLSearchParams({ symbol, interval, limit: String(limit) });
      if(startTime) params.set("startTime", String(startTime));
      const url = "https://fapi.binance.com/fapi/v1/klines?" + params.toString();
      const res = await fetch(url);
      if(!res.ok) throw new Error("HTTP "+res.status);
      const arr = await res.json();
      // Mapowanie do OHLC
      return arr.map(k => ({
        t: k[0],
        o: Number(k[1]),
        h: Number(k[2]),
        l: Number(k[3]),
        c: Number(k[4])
      }));
    }

    // Paginacja by uzyskać długą historię
    async function fetchLongHistory(symbol, interval, candlesWanted=1200){
      const CHUNK = 1000;
      let out = [];
      let startTime = undefined;
      for(let i=0;i<4 && out.length < candlesWanted;i++){
        const batch = await fetchBinanceKlines(symbol, interval, Math.min(CHUNK, candlesWanted - out.length), startTime);
        if(!batch.length) break;
        out = batch.concat(out); // budujemy od początku historii
        // kolejny skok wstecz:
        const firstTs = batch[0].t;
        startTime = firstTs - 1; // wszystko wcześniej od najstarszej świecy
      }
      return out;
    }

    // Syntetyczne świece – fallback offline
    function seededRandom(seed){
      let h = 2166136261 ^ seed.length;
      for (let i=0;i<seed.length;i++){
        h ^= seed.charCodeAt(i);
        h += (h<<1)+(h<<4)+(h<<7)+(h<<8)+(h<<24);
      }
      return ()=> {
        h += 0x6D2B79F5;
        let t = Math.imul(h ^ (h>>>15), 1 | h);
        t ^= t + Math.imul(t ^ (t>>>7), 61 | t);
        return ((t ^ (t>>>14)) >>> 0) / 4294967296;
      };
    }

    function genOHLC(symbol, points=240, startTs=Date.now()-points*3600_000, stepMs=3600_000){
      const rnd = seededRandom(symbol+"-ohlc");
      const data = [];
      let price = 100 + Math.floor(rnd()*1000);
      for(let i=0;i<points;i++){
        const drift = (rnd()-0.5)*2.0;
        const vol = 0.8 + rnd()*1.6;
        const open = price;
        let high = open + Math.abs(drift*5*vol) + rnd()*3;
        let low  = open - Math.abs(drift*5*vol) - rnd()*3;
        if(low<1) low = 1;
        let close = open + drift*4*vol + (rnd()-0.5)*2;
        if(close<1) close=1;
        high = Math.max(high, open, close);
        low = Math.min(low, open, close);
        data.push({ t: startTs + i*stepMs, o:open, h:high, l:low, c:close });
        price = close;
      }
      return data;
    }

    function drawCandles(canvas, data){
      const dpr = Math.max(1, window.devicePixelRatio || 1);
      const rect = canvas.getBoundingClientRect();
      const wpx = Math.max(10, Math.floor(rect.width * dpr));
      const hpx = Math.max(10, Math.floor(rect.height * dpr));
      if(canvas.width!==wpx) canvas.width = wpx;
      if(canvas.height!==hpx) canvas.height = hpx;
      const ctx = canvas.getContext("2d");
      ctx.setTransform(1,0,0,1,0,0);
      ctx.scale(dpr, dpr);
      ctx.clearRect(0,0,rect.width,rect.height);

      const padL=48, padR=10, padT=10, padB=22;
      const w = rect.width - padL - padR;
      const h = rect.height - padT - padB;
      if(w<=0 || h<=0 || data.length===0) return;

      let min = Infinity, max = -Infinity;
      for(const d of data){ if(d.l<min) min=d.l; if(d.h>max) max=d.h; }
      const y = (v)=> padT + (max - v) * (h / (max - min || 1));
      const candleW = Math.max(2, Math.floor(w / data.length * 0.6));
      const step = w / data.length;

      // grid
      const lines = 5;
      ctx.strokeStyle = "rgba(255,255,255,0.06)";
      ctx.lineWidth = 1;
      for(let i=0;i<=lines;i++){
        const gy = padT + (h/lines)*i;
        ctx.beginPath(); ctx.moveTo(padL, gy); ctx.lineTo(padL+w, gy); ctx.stroke();
      }

      // axis labels
      ctx.fillStyle = "#9db4ff";
      ctx.font = "11px ui-sans-serif, system-ui";
      ctx.textAlign = "right";
      ctx.textBaseline = "middle";
      for(let i=0;i<=lines;i++){
        const gy = padT + (h/lines)*i;
        const val = (max - (max-min)*(i/lines)).toFixed(2);
        ctx.fillText(val, padL-6, gy);
      }

      // candles
      for(let i=0;i<data.length;i++){
        const d = data[i];
        const cx = padL + i*step + step*0.5;
        const up = d.c >= d.o;
        const color = up ? "#27d980" : "#ff5c7a";
        ctx.strokeStyle = color;
        ctx.fillStyle = color;
        // wick
        ctx.beginPath();
        ctx.moveTo(cx, y(d.h));
        ctx.lineTo(cx, y(d.l));
        ctx.stroke();
        // body
        const bo = y(d.o), bc = y(d.c);
        const top = Math.min(bo, bc), height = Math.max(2, Math.abs(bc - bo));
        ctx.fillRect(cx - candleW/2, top, candleW, height);
      }
    }

    // Komponent wykresu świecowego: Online (Binance) lub Offline (syntetyczne)
    function CandlesView({symbol, interval, id}){
      const symNoPrefix = tvToBinanceSymbol(symbol);
      const holderId = "onoff_"+id;
      setTimeout(async ()=>{
        const holder = document.getElementById(holderId);
        if(!holder) return;

        const buildCanvas = (modeLabel)=>{
          holder.innerHTML = `
            <div class="${modeLabel==="Online"?"onwrap":"offwrap"}">
              <div class="${modeLabel==="Online"?"onhdr":"offhdr"}">
                <span class="badge">${modeLabel==="Online" ? "Dane z Binance" : "Tryb offline"}</span>
                <span class="status">${symbol} — interwał ${interval}</span>
              </div>
              <div style="position:relative">
                <canvas id="c${id}" class="chart"></canvas>
                <div class="legend">OHLC — ${modeLabel}</div>
              </div>
            </div>
          `;
          return document.getElementById("c"+id);
        };

        let data = [];
        let mode = "Online";
        try{
          // Pobierz długą historię (ok. 1200 świec)
          data = await fetchLongHistory(symNoPrefix, interval, 1200);
          if(!data || data.length===0) throw new Error("Brak danych");
        }catch(e){
          mode = "Offline";
          // krok w ms dla danego interwału
          const stepMap = { "1m":60_000, "5m":300_000, "15m":900_000, "1h":3_600_000, "4h":14_400_000, "1d":86_400_000 };
          const step = stepMap[interval] || 3_600_000;
          data = genOHLC(symbol, 300, Date.now()-300*step, step);
        }

        const canvas = buildCanvas(mode);
        const redraw = ()=> drawCandles(canvas, data);
        redraw();
        const ro = new ResizeObserver(redraw);
        ro.observe(canvas);

        // Auto-refresh online co 20s na ostatnie świece
        if(mode==="Online"){
          const timer = setInterval(async ()=>{
            try{
              const last = data[data.length-1]?.t || 0;
              const updates = await fetchBinanceKlines(symNoPrefix, interval, 500, last);
              if(updates.length){
                // scal: usuń świecę o tym samym timestampie i dołącz nowe
                const set = new Map(data.map(d=>[d.t,d]));
                for(const u of updates) set.set(u.t, u);
                data = Array.from(set.values()).sort((a,b)=>a.t-b.t);
                // utnij do 1500 aby nie rosnąć bez końca
                if(data.length>1500) data = data.slice(data.length-1500);
                redraw();
              }
            }catch(e){}
          }, 20000);
          canvas._cleanup = ()=>{ try{ ro.disconnect(); }catch{} clearInterval(timer); };
        }else{
          const timer = setInterval(redraw, 2000);
          canvas._cleanup = ()=>{ try{ ro.disconnect(); }catch{} clearInterval(timer); };
        }
      }, 0);

      return html`<div class="tv-holder" id=${holderId}></div>`;
    }

    // ----------------- UI / Tiles -----------------
    const state = {
      tiles: [],
      addTile(sym){
        const gap=16, defW=560, defH=380;
        const idx = state.tiles.length;
        const x = gap + (idx%2)*(defW+gap);
        const y = gap + Math.floor(idx/2)*(defH+gap);
        state.tiles = state.tiles.concat({ id: uuidv4(), symbol: sym.toUpperCase(), x, y, w:defW, h:defH, exchange: "BINANCE", interval:"1h" });
        rerender(); fitCanvas();
      },
      updateTile(id, patch){ state.tiles = state.tiles.map(t=> t.id===id? { ...t, ...patch }: t); rerender(); fitCanvas(); },
      removeTile(id){ state.tiles = state.tiles.filter(t=>t.id!==id); rerender(); fitCanvas(); },
      clear(){ state.tiles = []; rerender(); fitCanvas(); }
    };

    function Header(){
      return html`
        <header>
          <div class="brand">
            <div class="logo" aria-hidden="true"></div>
            <div>
              <h1 style="margin:0;font-size:18px">Krypto Dashboard</h1>
              <div class="muted" style="font-size:12px">
                Świece z darmowego API (Binance). Gdy offline – syntetyczny wykres.
              </div>
            </div>
          </div>
          <div style="display:flex;gap:8px;align-items:center;flex-wrap:wrap">
            <button class="btn" onClick=${()=>state.addTile("BTC")}>Dodaj BTC</button>
            <button class="btn alt" onClick=${()=>state.addTile("ETH")}>Dodaj ETH</button>
          </div>
        </header>
      `;
    }

    function Sidebar(){
      return html`
        <aside>
          <div class="panel">
            <h3 style="margin:0 0 10px 0;color:var(--muted)">Dodaj kafelek</h3>
            <div style="display:grid;grid-template-columns:1fr auto;gap:8px">
              <input id="symIn" class="input" placeholder="BTC" value="BTC" />
              <button class="btn" onClick=${()=>{
                const v = (document.getElementById("symIn").value || "BTC").toUpperCase();
                state.addTile(v);
              }}>Dodaj</button>
            </div>
            <div style="margin-top:10px;display:flex;gap:6px;flex-wrap:wrap">
              ${["BTC","ETH","SOL","BNB","XRP","DOGE","ADA","ARB","APT","SUI"].map(s => html`
                <button class="btn small alt" onClick=${()=>state.addTile(s)}>${s}</button>
              `)}
            </div>
            <p class="muted" style="font-size:12px;margin-top:12px">
              Najdłuższa historia: Binance klines (bez klucza). Offline – syntetyczny wykres świec.
            </p>
          </div>

          <div class="panel">
            <h3 style="margin:0 0 10px 0;color:var(--muted)">Wskazówki</h3>
            <ul style="margin:0;padding-left:18px;color:var(--muted);font-size:12px;line-height:1.5">
              <li>Przeciągaj kafel za uchwyt po lewej stronie belki.</li>
              <li>Zmieniaj rozmiar uchwytem w prawym dolnym rogu.</li>
              <li>Interwały: 1m/5m/15m/1h/4h/1d (w menu kafla).</li>
            </ul>
          </div>
        </aside>
      `;
    }

    function fitCanvas(){
      const gap=16;
      const canvas = document.getElementById("canvas");
      if(!canvas) return;
      let maxR=0, maxB=0;
      for(const t of state.tiles){
        maxR = Math.max(maxR, (t.x||0)+(t.w||0));
        maxB = Math.max(maxB, (t.y||0)+(t.h||0));
      }
      canvas.style.minWidth = Math.ceil(maxR + gap)+"px";
      canvas.style.minHeight = Math.ceil(maxB + gap)+"px";
    }

    function Tile({tile}){
      const onGrabDown = (e)=>{
        const tileRoot = e.currentTarget.closest(".tile");
        tileRoot.setPointerCapture(e.pointerId);
        drag = { sx:e.clientX, sy:e.clientY, ox: tile.x, oy: tile.y, id: tile.id };
      };
      const onMove = (e)=>{
        if(!drag || drag.id!==tile.id) return;
        const grid=8;
        const nx = Math.max(0, drag.ox + (e.clientX - drag.sx));
        const ny = Math.max(0, drag.oy + (e.clientY - drag.sy));
        state.updateTile(tile.id, { x: Math.round(nx/grid)*grid, y: Math.round(ny/grid)*grid });
      };
      const onUp = ()=>{ drag=null; };

      const onResizeDown = (e)=>{
        e.stopPropagation();
        const el = e.currentTarget;
        el.setPointerCapture(e.pointerId);
        resize = { sx:e.clientX, sy:e.clientY, ow: tile.w, oh: tile.h, id: tile.id };
      };
      const onResizeMove = (e)=>{
        if(!resize || resize.id!==tile.id) return;
        const grid=8;
        const nw = Math.max(440, resize.ow + (e.clientX - resize.sx));
        const nh = Math.max(260, resize.oh + (e.clientY - resize.sy));
        const rw = Math.round(nw/grid)*grid;
        const rh = Math.round(nh/grid)*grid;
        state.updateTile(tile.id, { w: rw, h: rh });
      };
      const onResizeUp = ()=>{ resize=null; };

      const sym = `${tile.exchange}:${tile.symbol}USDT`;

      return html`
        <div class="tile" style=${{ left: tile.x+"px", top: tile.y+"px", width: tile.w+"px", height: tile.h+"px" }}>
          <div class="toolbar" onPointerMove=${onMove} onPointerUp=${onUp}>
            <div class="grabber">
              <div class="grab-handle" title="Przeciągnij okno" onPointerDown=${onGrabDown} onPointerMove=${onMove} onPointerUp=${onUp}></div>
              <div class="title">${sym} — Świece (${tile.interval})</div>
            </div>
            <div class="actions">
              <select class="input" value=${tile.interval} onChange=${(e)=>state.updateTile(tile.id,{interval:e.currentTarget.value})}>
                ${Object.keys(INTERVALS).map(iv => html`<option value=${iv} selected=${tile.interval===iv}>${iv}</option>`)}
              </select>
              <button class="btn small alt" onClick=${()=> state.addTile(tile.symbol)}>Duplikuj</button>
              <button class="btn small alt" onClick=${()=> state.removeTile(tile.id)}>Usuń</button>
            </div>
          </div>
          <div class="content">
            ${html`<${CandlesView} symbol=${sym} interval=${tile.interval} id=${tile.id} />`}
          </div>
          <div class="resizer" title="Zmień rozmiar" onPointerDown=${onResizeDown} onPointerMove=${onResizeMove} onPointerUp=${onResizeUp}></div>
        </div>
      `;
    }
    let drag=null, resize=null;

    function Dashboard(){
      return html`
        ${Header()}
        <div class="row">
          ${Sidebar()}
          <main style="display:flex;flex-direction:column;gap:18px">
            <section class="panel">
              <h3 style="margin-top:0;color:var(--muted)">Płótno kafelków</h3>
              <div id="canvas" class="canvas">
                ${state.tiles.map(t=> html`<${Tile} key=${t.id} tile=${t} />`)}
              </div>
            </section>

            <section class="panel">
              <h3 style="margin-top:0;color:var(--muted)">Proponowane źródło danych</h3>
              <ul style="margin:0;padding-left:18px;color:var(--muted);font-size:12px;line-height:1.5">
                <li>Binance Futures klines: najdłuższe historie, brak klucza, stabilne API.</li>
                <li>W razie braku sieci lub błędu – automatyczny fallback na lokalne świece syntetyczne.</li>
                <li>Interwały: 1m, 5m, 15m, 1h, 4h, 1d. Historia 1200+ świec przez paginację.</li>
              </ul>
            </section>
          </main>
        </div>
        <footer style="padding:18px;color:var(--muted);font-size:12px;text-align:center">
          Dane z darmowego API Binance. Offline: syntetyczny wykres świecowy. Brak zewnętrznych assetów, wszystko lokalnie w JS.
        </footer>
      `;
    }

    function rerender(){
      render(html`<${Dashboard}/>`, document.getElementById("root"));
      fitCanvas();
    }

    (function init(){
      if(state.tiles.length===0){
        state.addTile("BTC");
        state.addTile("ETH");
      }
      rerender();
    })();
  </script>
</body>
</html>
