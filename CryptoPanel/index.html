<!DOCTYPE html>
<html lang="pl">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
  <title>Krypto Dashboard – Tryb offline z lokalnym wykresem + TradingView (gdy online)</title>
  <style>
    :root{
      --bg:#0b1020;
      --panel:#101832;
      --text:#e7ecff;
      --muted:#b7c3ff;
      --accent:#6aa9ff;
      --good:#27d980;
      --bad:#ff5c7a;
      --warn:#ffcc66;
      --border:rgba(255,255,255,0.08);
      --shadow: 0 10px 30px rgba(0,0,0,0.35);
      --radius:14px;
    }
    *{box-sizing:border-box}
    html,body,#root{height:100%}
    body{
      margin:0;
      font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Inter, "Helvetica Neue", Arial;
      color:var(--text);
      background:
        radial-gradient(60vw 60vw at 10% -10%, rgba(106,169,255,0.15), transparent 60%),
        radial-gradient(50vw 50vw at 110% 10%, rgba(255,92,122,0.12), transparent 60%),
        linear-gradient(180deg, #090d1a, #0b1020 30%, #0b1020 100%);
      overflow:auto;
    }
    header{
      display:flex;align-items:center;justify-content:space-between;
      padding:14px 16px;border-bottom:1px solid var(--border);
      backdrop-filter: blur(8px);
      position:sticky;top:0;z-index:50;
      background: linear-gradient(180deg, rgba(16,24,50,0.85), rgba(16,24,50,0.55));
    }
    .brand{display:flex;gap:12px;align-items:center}
    .logo{
      width:34px;height:34px;border-radius:10px;
      background: conic-gradient(from 220deg, #6aa9ff, #8b6aff, #ff5c7a, #6aa9ff);
      box-shadow: inset 0 0 20px rgba(255,255,255,0.25), 0 8px 20px rgba(106,169,255,0.35);
      position:relative;
    }
    .logo:after{content:"";position:absolute;inset:5px;border-radius:8px;background:var(--panel);box-shadow: inset 0 0 12px rgba(0,0,0,0.45)}
    .muted{color:var(--muted)}
    .row{
      display:grid;grid-template-columns: 320px 1fr;gap:18px;
      padding:18px clamp(12px, 3vw, 22px) 22px clamp(12px, 3vw, 22px);
      align-items:start;
    }
    .panel{
      background: linear-gradient(180deg, rgba(16,24,50,0.75), rgba(16,24,50,0.5));
      border:1px solid var(--border);border-radius:var(--radius);box-shadow: var(--shadow);padding:14px;
    }
    .btn{
      background:linear-gradient(180deg, #6aa9ff, #3b7be6);
      color:#071024;border:none;padding:10px 12px;border-radius:10px;font-weight:700;
      cursor:pointer;box-shadow: 0 6px 18px rgba(106,169,255,0.35);
      transition: transform .08s ease, box-shadow .2s ease; font-size:13px;
    }
    .btn.small{padding:6px 8px;font-size:12px;border-radius:8px}
    .btn.alt{
      background:linear-gradient(180deg, #1e2b55, #142043);
      color:var(--text);border:1px solid var(--border); box-shadow:none; font-weight:600;
    }
    .input, select{
      background:linear-gradient(180deg, #0c1430, #0b132a);
      border:1px solid var(--border);color:var(--text);
      padding:10px;border-radius:10px;outline:none;font-size:13px;
    }
    aside{display:flex;flex-direction:column;gap:14px;position:sticky;top:70px}
    .canvas{
      position:relative;border-radius:12px;border:1px solid var(--border);
      background: linear-gradient(180deg, rgba(24,36,80,0.35), rgba(12,18,40,0.45));
      min-height: 520px;overflow:auto;
    }
    .tile{
      position:absolute;
      background: #0b1330;
      border:1px solid var(--border);
      border-radius:6px;
      box-shadow: var(--shadow);
      overflow:hidden;
      display:flex;flex-direction:column;
      touch-action:none;
      pointer-events:auto;
    }
    .tile .toolbar{
      display:flex;align-items:center;justify-content:space-between;gap:6px;
      padding:6px 8px;border-bottom:1px solid var(--border);
      background:#0c1230;
      cursor: default;
      user-select:none;
    }
    .grabber{display:flex;align-items:center;gap:6px}
    .grab-handle{
      width:14px;height:14px;border-radius:3px;border:1px dashed rgba(255,255,255,0.25);
      background:linear-gradient(180deg, rgba(255,255,255,0.06), rgba(255,255,255,0.02));
      cursor: grab;
    }
    .title{font-size:12px;color:var(--muted)}
    .actions{display:flex;gap:6px;flex-wrap:wrap}
    .content{position:relative;flex:1;min-height:140px}
    .tv-holder{position:absolute;inset:0}
    .resizer{
      position:absolute;right:6px;bottom:6px;width:14px;height:14px;border-radius:4px;border:1px solid var(--border);
      background:linear-gradient(135deg, rgba(106,169,255,0.45), rgba(106,169,255,0.15));
      cursor:nwse-resize;opacity:0.85;
    }
    @media (max-width: 1100px){
      .row{grid-template-columns: 1fr;gap:14px}
      .canvas{min-height:420px}
      header{gap:10px;flex-wrap:wrap}
    }
    .table{width:100%;border-collapse:separate;border-spacing:0;overflow:hidden;border-radius:12px;border:1px solid var(--border)}
    .table th, .table td{padding:10px;border-bottom:1px solid var(--border);font-size:13px;text-align:left}
    .table th{color:var(--muted);font-weight:600;background:rgba(16,24,50,0.55);backdrop-filter: blur(6px)}
    .modal{position:fixed;inset:0;display:grid;place-items:center;background:rgba(0,0,0,0.5);z-index:100}
    /* Offline canvas styles */
    .offwrap{position:absolute;inset:0;display:grid;grid-template-rows:auto 1fr}
    .offhdr{display:flex;align-items:center;gap:8px;padding:6px 8px;border-bottom:1px solid var(--border);background:#0b122a}
    .badge{font-size:11px;padding:2px 6px;border-radius:6px;background:#1a2b55;color:#9ec1ff;border:1px solid rgba(106,169,255,0.35)}
    canvas.chart{width:100%;height:100%;display:block;background:linear-gradient(180deg,#0b1128,#0a1024)}
    .legend{position:absolute;top:8px;right:8px;background:rgba(0,0,0,0.35);padding:6px 8px;border-radius:8px;font-size:12px;color:#cfe0ff;border:1px solid rgba(255,255,255,0.1)}
  </style>
  <script type="importmap">
    {
      "imports": {
        "preact": "https://cdn.jsdelivr.net/npm/preact@10.19.6/dist/preact.module.js",
        "htm": "https://cdn.jsdelivr.net/npm/htm@3.1.1/dist/htm.module.js",
        "uuid": "https://cdn.jsdelivr.net/npm/uuid@9.0.1/dist/esm-browser/index.js"
      }
    }
  </script>
</head>
<body>
  <div id="root"></div>

  <script type="module">
    import { h, render } from "preact";
    import htm from "htm";
    import { v4 as uuidv4 } from "uuid";
    const html = htm.bind(h);

    // Detekcja łączności – jeżeli offline lub nie osiągalny TradingView, pokazujemy lokalny wykres (proceduralny).
    let online = navigator.onLine;
    window.addEventListener("online", ()=>{ online = true; rerender(); });
    window.addEventListener("offline", ()=>{ online = false; rerender(); });

    // Funkcja testująca dostępność domeny TradingView w bezpieczny sposób (HEAD na zasób statyczny).
    async function checkTradingViewReachable(timeout=2500){
      if(!navigator.onLine) return false;
      const controller = new AbortController();
      const t = setTimeout(()=>controller.abort(), timeout);
      try{
        // lekki zasób: ping.gif – jeśli blokada sieci/CSP, złapiemy błąd i przełączymy na offline chart
        const res = await fetch("https://s3.tradingview.com/tv.js", { method:"HEAD", mode:"no-cors", signal: controller.signal });
        clearTimeout(t);
        // no-cors nie zwróci statusu, ale brak wyjątku sugeruje, że połączenie możliwe
        return true;
      }catch(e){
        clearTimeout(t);
        return false;
      }
    }

    const state = {
      tiles: [],
      addTile(sym){
        const gap=16, defW=520, defH=360;
        const idx = state.tiles.length;
        const x = gap + (idx%2)*(defW+gap);
        const y = gap + Math.floor(idx/2)*(defH+gap);
        state.tiles = state.tiles.concat({ id: uuidv4(), symbol: sym.toUpperCase(), x, y, w:defW, h:defH, exchange: bestExchange(sym) });
        rerender(); fitCanvas();
      },
      updateTile(id, patch){ state.tiles = state.tiles.map(t=> t.id===id? { ...t, ...patch }: t); rerender(); fitCanvas(); },
      removeTile(id){ state.tiles = state.tiles.filter(t=>t.id!==id); rerender(); fitCanvas(); },
      clear(){ state.tiles = []; rerender(); fitCanvas(); }
    };

    function bestExchange(sym){
      const map = { BTC:"BINANCE", ETH:"BINANCE", SOL:"BINANCE", BNB:"BINANCE", XRP:"BINANCE", DOGE:"BINANCE", ADA:"BINANCE", ARB:"BINANCE", APT:"BINANCE", SUI:"BINANCE" };
      return map[sym] || "BINANCE";
    }

    function Header(){
      return html`
        <header>
          <div class="brand">
            <div class="logo" aria-hidden="true"></div>
            <div>
              <h1 style="margin:0;font-size:18px">Krypto Dashboard</h1>
              <div class="muted" style="font-size:12px">
                Działa offline: lokalny wykres. Gdy online: automatycznie ładuje TradingView.
              </div>
            </div>
          </div>
          <div style="display:flex;gap:8px;align-items:center;flex-wrap:wrap">
            <button class="btn" onClick=${()=>state.addTile("BTC")}>Dodaj BTC</button>
            <button class="btn alt" onClick=${()=>state.addTile("ETH")}>Dodaj ETH</button>
          </div>
        </header>
      `;
    }

    function Sidebar(){
      return html`
        <aside>
          <div class="panel">
            <h3 style="margin:0 0 10px 0;color:var(--muted)">Dodaj kafelek</h3>
            <div style="display:grid;grid-template-columns:1fr auto;gap:8px">
              <input id="symIn" class="input" placeholder="BTC" value="BTC" />
              <button class="btn" onClick=${()=>{
                const v = (document.getElementById("symIn").value || "BTC").toUpperCase();
                state.addTile(v);
              }}>Dodaj</button>
            </div>
            <div style="margin-top:10px;display:flex;gap:6px;flex-wrap:wrap">
              ${["BTC","ETH","SOL","BNB","XRP","DOGE","ADA","ARB","APT","SUI"].map(s => html`
                <button class="btn small alt" onClick=${()=>state.addTile(s)}>${s}</button>
              `)}
            </div>
            <div style="margin-top:10px;display:flex;gap:8px">
              <button class="btn alt" onClick=${()=>state.clear()}>Wyczyść</button>
            </div>
            <p class="muted" style="font-size:12px;margin-top:12px">
              Jeśli TradingView jest niedostępny, widzisz lokalny wykres świecowy z danych syntetycznych.
            </p>
          </div>

          <div class="panel">
            <h3 style="margin:0 0 10px 0;color:var(--muted)">Wskazówki</h3>
            <ul style="margin:0;padding-left:18px;color:var(--muted);font-size:12px;line-height:1.5">
              <li>Przeciągaj kafel za uchwyt po lewej stronie belki.</li>
              <li>Zmieniaj rozmiar uchwytem w prawym dolnym rogu.</li>
              <li>Automatyczne przełączanie między TradingView a lokalnym wykresem.</li>
            </ul>
          </div>
        </aside>
      `;
    }

    function fitCanvas(){
      const gap=16;
      const canvas = document.getElementById("canvas");
      if(!canvas) return;
      let maxR=0, maxB=0;
      for(const t of state.tiles){
        maxR = Math.max(maxR, (t.x||0)+(t.w||0));
        maxB = Math.max(maxB, (t.y||0)+(t.h||0));
      }
      canvas.style.minWidth = Math.ceil(maxR + gap)+"px";
      canvas.style.minHeight = Math.ceil(maxB + gap)+"px";
    }

    // Proceduralne dane świecowe (placebo offline) – deterministyczne, zależne od symbolu
    function seededRandom(seed){
      let h = 2166136261 ^ seed.length;
      for (let i=0;i<seed.length;i++){
        h ^= seed.charCodeAt(i);
        h += (h<<1)+(h<<4)+(h<<7)+(h<<8)+(h<<24);
      }
      return ()=> {
        h += 0x6D2B79F5;
        let t = Math.imul(h ^ (h>>>15), 1 | h);
        t ^= t + Math.imul(t ^ (t>>>7), 61 | t);
        return ((t ^ (t>>>14)) >>> 0) / 4294967296;
      };
    }

    function genOHLC(symbol, points=240){
      const rnd = seededRandom(symbol+"-ohlc");
      const data = [];
      let price = 100 + Math.floor(rnd()*1000);
      for(let i=0;i<points;i++){
        const drift = (rnd()-0.5)*2.0;
        const vol = 0.8 + rnd()*1.6;
        const open = price;
        let high = open + Math.abs(drift*5*vol) + rnd()*3;
        let low  = open - Math.abs(drift*5*vol) - rnd()*3;
        if(low<1) low = 1;
        let close = open + drift*4*vol + (rnd()-0.5)*2;
        if(close<1) close=1;
        high = Math.max(high, open, close);
        low = Math.min(low, open, close);
        const up = close>=open;
        data.push({ o:open, h:high, l:low, c:close, up });
        price = close;
      }
      return data;
    }

    function drawCandles(canvas, data){
      const dpr = Math.max(1, window.devicePixelRatio || 1);
      const rect = canvas.getBoundingClientRect();
      canvas.width = Math.floor(rect.width * dpr);
      canvas.height = Math.floor(rect.height * dpr);
      const ctx = canvas.getContext("2d");
      ctx.scale(dpr, dpr);
      ctx.clearRect(0,0,rect.width,rect.height);

      const padL=40, padR=10, padT=10, padB=20;
      const w = rect.width - padL - padR;
      const h = rect.height - padT - padB;
      if(w<=0 || h<=0 || data.length===0) return;

      let min = Infinity, max = -Infinity;
      for(const d of data){ if(d.l<min) min=d.l; if(d.h>max) max=d.h; }
      const y = (v)=> padT + (max - v) * (h / (max - min || 1));
      const candleW = Math.max(3, Math.floor(w / data.length * 0.7));
      const step = w / data.length;

      // grid
      const lines = 5;
      ctx.strokeStyle = "rgba(255,255,255,0.06)";
      ctx.lineWidth = 1;
      for(let i=0;i<=lines;i++){
        const gy = padT + (h/lines)*i;
        ctx.beginPath(); ctx.moveTo(padL, gy); ctx.lineTo(padL+w, gy); ctx.stroke();
      }

      // axis labels
      ctx.fillStyle = "#9db4ff";
      ctx.font = "11px ui-sans-serif, system-ui";
      ctx.textAlign = "right";
      ctx.textBaseline = "middle";
      for(let i=0;i<=lines;i++){
        const gy = padT + (h/lines)*i;
        const val = (max - (max-min)*(i/lines)).toFixed(2);
        ctx.fillText(val, padL-6, gy);
      }

      // candles
      for(let i=0;i<data.length;i++){
        const d = data[i];
        const cx = padL + i*step + step*0.5;
        ctx.strokeStyle = d.up ? "#27d980" : "#ff5c7a";
        ctx.fillStyle = d.up ? "#27d980" : "#ff5c7a";
        // wick
        ctx.beginPath();
        ctx.moveTo(cx, y(d.h));
        ctx.lineTo(cx, y(d.l));
        ctx.stroke();
        // body
        const bo = y(d.o), bc = y(d.c);
        const top = Math.min(bo, bc), height = Math.max(2, Math.abs(bc - bo));
        ctx.fillRect(cx - candleW/2, top, candleW, height);
      }
    }

    function OfflineChart({symbol, id}){
      // Kontener offline: canvas + prosta legenda
      setTimeout(()=>{
        const canvas = document.getElementById("offc_"+id);
        if(!canvas) return;
        const redraw = ()=>{
          const data = genOHLC(symbol, 200);
          drawCandles(canvas, data);
        };
        redraw();
        const ro = new ResizeObserver(redraw);
        ro.observe(canvas);
        const t = setInterval(redraw, 2000); // delikatne "odświeżanie"
        canvas._cleanup = ()=>{ try{ ro.disconnect(); }catch{} clearInterval(t); };
      }, 0);

      return html`
        <div class="offwrap">
          <div class="offhdr">
            <span class="badge">Tryb offline</span>
            <span style="font-size:12px;color:var(--muted)">${symbol} — lokalny wykres świecowy</span>
          </div>
          <div style="position:relative">
            <canvas id=${"offc_"+id} class="chart"></canvas>
            <div class="legend">Otw/Wys/Nis/Zam – dane syntetyczne</div>
          </div>
        </div>
      `;
    }

    function Tile({tile}){
      const onGrabDown = (e)=>{
        const tileRoot = e.currentTarget.closest(".tile");
        tileRoot.setPointerCapture(e.pointerId);
        drag = { sx:e.clientX, sy:e.clientY, ox: tile.x, oy: tile.y, id: tile.id };
      };
      const onMove = (e)=>{
        if(!drag || drag.id!==tile.id) return;
        const grid=8;
        const nx = Math.max(0, drag.ox + (e.clientX - drag.sx));
        const ny = Math.max(0, drag.oy + (e.clientY - drag.sy));
        state.updateTile(tile.id, { x: Math.round(nx/grid)*grid, y: Math.round(ny/grid)*grid });
      };
      const onUp = ()=>{ drag=null; };

      const onResizeDown = (e)=>{
        e.stopPropagation();
        const el = e.currentTarget;
        el.setPointerCapture(e.pointerId);
        resize = { sx:e.clientX, sy:e.clientY, ow: tile.w, oh: tile.h, id: tile.id };
      };
      const onResizeMove = (e)=>{
        if(!resize || resize.id!==tile.id) return;
        const grid=8;
        const nw = Math.max(440, resize.ow + (e.clientX - resize.sx));
        const nh = Math.max(260, resize.oh + (e.clientY - resize.sy));
        const rw = Math.round(nw/grid)*grid;
        const rh = Math.round(nh/grid)*grid;
        state.updateTile(tile.id, { w: rw, h: rh });
        const frame = document.getElementById("tvf_"+tile.id);
        if(frame) requestAnimationFrame(()=>{ frame.style.width = "100%"; frame.style.height = "100%"; });
      };
      const onResizeUp = ()=>{ resize=null; };

      const sym = `${tile.exchange}:${tile.symbol}USDT`;

      // Render: jeśli TV osiągalny -> iframe z TV, w przeciwnym wypadku lokalny wykres
      const content = html`<div class="tv-holder" id=${"ctn_"+tile.id}></div>`;

      // Wstrzyknięcie po renderze
      setTimeout(async ()=>{
        const holder = document.getElementById("ctn_"+tile.id);
        if(!holder) return;
        // spróbuj wykryć dostępność TradingView
        const tvOk = await checkTradingViewReachable();
        if(tvOk){
          // IFRAME z widgetem TradingView
          const iframe = document.createElement("iframe");
          iframe.id = "tvf_"+tile.id;
          iframe.title = "tv_"+tile.symbol;
          iframe.style.cssText = "border:0;display:block;width:100%;height:100%;background:#0b1128";
          iframe.sandbox = "allow-scripts allow-same-origin allow-popups allow-forms";
          iframe.loading = "lazy";
          holder.innerHTML = "";
          holder.appendChild(iframe);
          try{
            const doc = iframe.contentDocument || iframe.contentWindow?.document;
            doc.open();
            doc.write(`<!DOCTYPE html><html><head>
              <meta charset="utf-8"/>
              <meta name="viewport" content="width=device-width,initial-scale=1"/>
              <style>html,body,#container{height:100%;margin:0;background:#0b1128}</style>
            </head><body>
              <div id="container"></div>
              <script src="https://s3.tradingview.com/external-embedding/embed-widget-advanced-chart.js" async><\/script>
              <script>
                window.addEventListener('DOMContentLoaded', function(){
                  try{
                    new window.TradingView.widget({
                      autosize: true,
                      symbol: ${JSON.stringify(sym)},
                      interval: "60",
                      timezone: "Etc/UTC",
                      theme: "dark",
                      style: "1",
                      locale: "pl",
                      enable_publishing: false,
                      allow_symbol_change: true,
                      withdateranges: true,
                      details: true,
                      hotlist: false,
                      calendar: false,
                      hide_side_toolbar: false,
                      studies: [],
                      container_id: "container"
                    });
                  }catch(e){
                    document.body.innerHTML = '<div style="display:grid;place-items:center;height:100%;color:#b7c3ff;background:#0b1128">Nie udało się zainicjować TradingView.</div>';
                  }
                });
              <\/script>
            </body></html>`);
            doc.close();
          }catch(e){
            // fallback do lokalnego wykresu
            holder.innerHTML = "";
            render(html`<${OfflineChart} symbol=${sym} id=${tile.id}/>`, holder);
          }
        }else{
          holder.innerHTML = "";
          render(html`<${OfflineChart} symbol=${sym} id=${tile.id}/>`, holder);
        }
      }, 0);

      return html`
        <div class="tile" style=${{ left: tile.x+"px", top: tile.y+"px", width: tile.w+"px", height: tile.h+"px" }}>
          <div class="toolbar" onPointerMove=${onMove} onPointerUp=${onUp}>
            <div class="grabber">
              <div class="grab-handle" title="Przeciągnij okno" onPointerDown=${onGrabDown} onPointerMove=${onMove} onPointerUp=${onUp}></div>
              <div class="title">${sym} — Wykres</div>
            </div>
            <div class="actions">
              <button class="btn small alt" onClick=${()=> state.addTile(tile.symbol)}>Duplikuj</button>
              <button class="btn small alt" onClick=${()=> state.removeTile(tile.id)}>Usuń</button>
            </div>
          </div>
          <div class="content">
            ${content}
          </div>
          <div class="resizer" title="Zmień rozmiar" onPointerDown=${onResizeDown} onPointerMove=${onResizeMove} onPointerUp=${onResizeUp}></div>
        </div>
      `;
    }
    let drag=null, resize=null;

    function Dashboard(){
      return html`
        ${Header()}
        <div class="row">
          ${Sidebar()}
          <main style="display:flex;flex-direction:column;gap:18px">
            <section class="panel">
              <h3 style="margin-top:0;color:var(--muted)">Płótno kafelków</h3>
              <div id="canvas" class="canvas">
                ${state.tiles.map(t=> html`<${Tile} key=${t.id} tile=${t} />`)}
              </div>
            </section>

            <section class="panel">
              <h3 style="margin-top:0;color:var(--muted)">Przykładowe symbole</h3>
              <div style="display:flex;flex-wrap:wrap;gap:8px">
                ${["BTC","ETH","SOL","BNB","XRP","DOGE","ADA","ARB","APT","SUI"].map(s=> html`
                  <button class="btn small" onClick=${()=>state.addTile(s)}>${s}</button>
                `)}
              </div>
              <div class="muted" style="font-size:12px;margin-top:8px">
                Gdy połączenie z TradingView jest niedostępne, zobaczysz lokalny wykres świecowy (syntetyczny).
              </div>
            </section>

            <section class="panel">
              <h3 style="margin-top:0;color:var(--muted)">FAQ</h3>
              <table class="table">
                <tbody>
                  <tr><th>Co z komunikatem "Brak połączenia z TradingView"?</th><td>Teraz, gdy TV niedostępny, wyświetlamy lokalny wykres zamiast pustego komunikatu.</td></tr>
                  <tr><th>Czy to prawdziwe dane?</th><td>Offline używa danych syntetycznych. Po odzyskaniu łącza ładuje się wykres TradingView z prawdziwymi danymi.</td></tr>
                  <tr><th>Przełączanie</th><td>Automatyczne: aplikacja sprawdza dostępność TV i przełącza widok.</td></tr>
                </tbody>
              </table>
            </section>
          </main>
        </div>
        <footer style="padding:18px;color:var(--muted);font-size:12px;text-align:center">
          Tryb hybrydowy: lokalny wykres offline + TradingView online.
        </footer>
      `;
    }

    function rerender(){
      render(html`<${Dashboard}/>`, document.getElementById("root"));
      fitCanvas();
    }

    (function init(){
      if(state.tiles.length===0){
        state.addTile("BTC");
        state.addTile("ETH");
      }
      rerender();
    })();
  </script>
</body>
</html>
