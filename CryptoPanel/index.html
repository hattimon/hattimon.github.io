<!DOCTYPE html>
<html lang="pl">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Krypto Dashboard – Lokalny zapis (konto + dashboard)</title>
  <style>
    :root{
      --bg:#0b1020;
      --panel:#101832;
      --panel-2:#0f1a3d;
      --text:#e7ecff;
      --muted:#b7c3ff;
      --accent:#6aa9ff;
      --good:#27d980;
      --bad:#ff5c7a;
      --warn:#ffcc66;
      --border:rgba(255,255,255,0.08);
      --shadow: 0 10px 30px rgba(0,0,0,0.35);
      --radius:14px;
    }
    *{box-sizing:border-box}
    html,body{height:100%}
    body{
      margin:0;
      font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Inter, "Helvetica Neue", Arial;
      background:
        radial-gradient(60vw 60vw at 10% -10%, rgba(106,169,255,0.15), transparent 60%),
        radial-gradient(50vw 50vw at 110% 10%, rgba(255,92,122,0.12), transparent 60%),
        linear-gradient(180deg, #090d1a, #0b1020 30%, #0b1020 100%);
      color:var(--text);
    }
    header{
      display:flex;align-items:center;justify-content:space-between;
      padding:18px 22px;border-bottom:1px solid var(--border);
      backdrop-filter: blur(8px);
      position:sticky;top:0;z-index:20;
      background: linear-gradient(180deg, rgba(16,24,50,0.75), rgba(16,24,50,0.45));
    }
    .brand{display:flex;gap:12px;align-items:center}
    .logo{
      width:38px;height:38px;border-radius:10px;
      background: conic-gradient(from 220deg, #6aa9ff, #8b6aff, #ff5c7a, #6aa9ff);
      box-shadow: inset 0 0 20px rgba(255,255,255,0.25), 0 8px 20px rgba(106,169,255,0.35);
      position:relative;
    }
    .logo:after{content:"";position:absolute;inset:5px;border-radius:8px;background:var(--panel);box-shadow: inset 0 0 12px rgba(0,0,0,0.45)}
    .brand h1{font-size:18px;margin:0;letter-spacing:0.4px}
    .muted{color:var(--muted)}
    .row{display:grid;grid-template-columns: 300px 1fr;gap:18px;padding:18px;align-items:start}
    aside{display:flex;flex-direction:column;gap:14px;position:sticky;top:76px;height:calc(100dvh - 90px);overflow:auto;padding-right:4px}
    .panel{
      background: linear-gradient(180deg, rgba(16,24,50,0.75), rgba(16,24,50,0.5));
      border:1px solid var(--border);border-radius:var(--radius);box-shadow: var(--shadow);padding:14px;
    }
    .panel h3{margin:0 0 10px 0;font-size:14px;color:var(--muted);font-weight:600;letter-spacing:0.5px}
    .btn{
      background:linear-gradient(180deg, #6aa9ff, #3b7be6);
      color:#071024;border:none;padding:10px 12px;border-radius:10px;font-weight:700;
      cursor:pointer;box-shadow: 0 6px 18px rgba(106,169,255,0.35);
      transition: transform .08s ease, box-shadow .2s ease; font-size:13px;
    }
    .btn.small{padding:6px 8px;font-size:12px;border-radius:8px}
    .btn:active{transform: translateY(1px); box-shadow: 0 3px 10px rgba(106,169,255,0.3)}
    .btn.alt{
      background:linear-gradient(180deg, #1e2b55, #142043);
      color:var(--text);border:1px solid var(--border); box-shadow:none; font-weight:600;
    }
    .field{display:flex;flex-direction:column;gap:6px;margin-bottom:10px}
    .field label{font-size:12px;color:var(--muted)}
    .input, select, textarea{
      background:linear-gradient(180deg, #0c1430, #0b132a);
      border:1px solid var(--border);color:var(--text);
      padding:10px;border-radius:10px;outline:none;font-size:13px;
    }
    .kpis{display:grid;grid-template-columns: repeat(4, minmax(0,1fr)); gap:12px}
    .kpi{padding:12px;border-radius:12px;border:1px solid var(--border);background: linear-gradient(180deg, rgba(24,36,80,0.6), rgba(15,26,61,0.45))}
    .kpi .label{font-size:12px;color:var(--muted)}
    .kpi .value{font-size:18px;font-weight:800;margin-top:4px; display:block; line-height:1.2}
    .kpi .delta{font-size:12px;margin-top:6px; display:block; line-height:1.2}
    .good{color:var(--good)} .bad{color:var(--bad)} .warn{color:var(--warn)}
    .table{width:100%;border-collapse:separate;border-spacing:0;overflow:hidden;border-radius:12px;border:1px solid var(--border)}
    .table th, .table td{padding:10px;border-bottom:1px solid var(--border);font-size:13px;text-align:left}
    .table th{color:var(--muted);font-weight:600;background:rgba(16,24,50,0.55);backdrop-filter: blur(6px)}
    .table tr:nth-child(even) td{background:rgba(10,16,36,0.35)}
    .tabs{display:flex;gap:8px;margin-bottom:8px;flex-wrap:wrap}
    .tab{padding:8px 10px;border-radius:10px;border:1px solid var(--border);cursor:pointer;background:linear-gradient(180deg, #0c1430, #0b132a);color:var(--muted);font-size:12px}
    .tab.active{color:var(--text);border-color:#3856b7; box-shadow: inset 0 0 0 1px rgba(106,169,255,0.25)}
    footer{padding:18px;color:var(--muted);font-size:12px;text-align:center}
    .two-col{display:grid;grid-template-columns: 1fr 1fr;gap:12px}
    .pill{display:inline-flex;align-items:center;gap:6px;padding:6px 8px;border-radius:999px;border:1px solid var(--border);font-size:12px;background:#0b1330}

    .canvas{
      position:relative;
      border-radius:12px;
      border:1px solid var(--border);
      background: linear-gradient(180deg, rgba(24,36,80,0.35), rgba(12,18,40,0.45));
      min-height: 520px;
      overflow:hidden;
    }
    .tile{
      position:absolute;
      background: radial-gradient(120% 120% at -10% -10%, rgba(106,169,255,0.12), transparent 40%), #0b1330;
      border:1px solid var(--border);
      border-radius:12px;
      box-shadow: var(--shadow);
      overflow:hidden;
      display:flex;flex-direction:column;
    }
    .tile.locked{box-shadow:none}
    .tile .toolbar{
      display:flex;align-items:center;justify-content:space-between;
      gap:8px;padding:8px;border-bottom:1px solid var(--border);
      background: linear-gradient(180deg, rgba(16,24,50,0.75), rgba(16,24,50,0.35));
      cursor: move;
      user-select:none;
    }
    .tile.locked .toolbar{cursor:default}
    .toolbar .title{font-size:12px;color:var(--muted)}
    .toolbar .actions{display:flex;gap:6px}
    .statline{
      display:grid;grid-template-columns: 1fr repeat(4, max-content);gap:10px;
      align-items:center;padding:8px;border-top:1px solid var(--border);font-size:12px;
      background: rgba(10,16,36,0.35)
    }
    .content{position:relative;flex:1;min-height:120px}
    .content canvas{position:absolute;inset:0;width:100%;height:100%}
    .resizer{position:absolute;right:6px;bottom:6px;width:14px;height:14px;border-radius:4px;border:1px solid var(--border);
      background:linear-gradient(135deg, rgba(106,169,255,0.45), rgba(106,169,255,0.15));
      cursor: nwse-resize;opacity:0.85;
    }
    .locked .resizer{display:none}
    .ghost{position:absolute;border:1px dashed #6aa9ff;background:rgba(106,169,255,0.08);border-radius:12px;pointer-events:none}
    .controls{display:flex;gap:8px;flex-wrap:wrap}
    .panel.flexcol{display:flex;flex-direction:column;gap:12px}
    /* Stats-only layout: each field separate, never overlapping */
    .stats-only{display:grid; gap:8px; max-height:400px; overflow:auto}
    .mini-row{
      display:grid;
      grid-template-columns: 1fr;
      gap:8px;
      border:1px solid var(--border);
      border-radius:10px;
      padding:10px;
      background:linear-gradient(180deg, rgba(24,36,80,0.35), rgba(12,18,40,0.35));
    }
    .mini-row > .cell{display:flex; justify-content:space-between; align-items:center; gap:10px; min-width:0}
    .mini-row .label{font-size:11px;color:var(--muted)}
    .mini-row .value{font-weight:700; white-space:nowrap}
    .badge{font-size:11px;color:var(--muted)}
    .hr{height:1px;background:var(--border);margin:8px 0}
    .hint{font-size:12px;color:var(--muted)}
    @media (min-width: 560px){
      .mini-row{grid-template-columns: repeat(2, minmax(0,1fr))}
    }
    @media (min-width: 860px){
      .mini-row{grid-template-columns: repeat(3, minmax(0,1fr))}
    }
    @media (max-width: 1100px){
      .row{grid-template-columns: 1fr}
      aside{position:relative;height:auto}
      .kpis{grid-template-columns: repeat(2, minmax(0,1fr))}
      .canvas{min-height:420px}
    }

    /* Ensure KPI value and delta are separated and never overlap */
    .kpi .value, .kpi .delta{display:block}
    .kpi .value{white-space:nowrap; overflow:hidden; text-overflow:ellipsis}
    .kpi .delta{white-space:nowrap}
  </style>
  <script type="importmap">
    {
      "imports": {
        "chart.js": "https://cdn.jsdelivr.net/npm/chart.js@4.4.4/dist/chart.umd.js",
        "uuid": "https://cdn.jsdelivr.net/npm/uuid@9.0.1/dist/esm-browser/index.js"
      }
    }
  </script>
</head>
<body>
  <header>
    <div class="brand">
      <div class="logo" aria-hidden="true"></div>
      <div>
        <h1>Krypto Dashboard</h1>
      <div class="muted" style="font-size:12px">Wszystko zapisane lokalnie: konta, pozycje i układ kafelków</div>
      </div>
    </div>
    <div style="display:flex;gap:8px;align-items:center">
      <span id="currentUser" class="pill">Gość</span>
      <button id="demoData" class="btn">Załaduj demo</button>
    </div>
  </header>

  <div class="row">
    <aside>
      <div class="panel">
        <h3>Użytkownik (lokalny storage)</h3>
        <div class="field"><label>Email</label><input id="email" class="input" placeholder="you@example.com" /></div>
        <div class="field"><label>Hasło</label><input id="password" class="input" type="password" placeholder="••••••••" /></div>
        <div class="controls">
          <button id="register" class="btn alt">Zarejestruj</button>
          <button id="login" class="btn">Zaloguj</button>
          <button id="logout" class="btn alt">Wyloguj</button>
        </div>
        <div class="hr"></div>
        <div class="hint">Dane są zapisywane w localStorage (per przeglądarka). Sesja w sessionStorage.</div>
      </div>

      <div class="panel">
        <h3>Pozycja ręczna</h3>
        <div class="two-col">
          <div class="field"><label>Symbol</label><input id="mSymbol" class="input" placeholder="BTC" /></div>
          <div class="field"><label>Ilość</label><input id="mAmount" type="number" step="any" class="input" placeholder="0.123" /></div>
        </div>
        <div class="field"><label>Śr. cena zakupu (USD)</label><input id="mAvgPrice" type="number" step="any" class="input" placeholder="30000" /></div>
        <div class="controls">
          <button id="addManual" class="btn">Dodaj pozycję</button>
          <button id="addTile" class="btn alt">Dodaj kafelek z wykresem</button>
        </div>
      </div>

      <div class="panel">
        <h3>Konfiguracja kafelków</h3>
        <div class="controls">
          <button id="lockToggle" class="btn">Zablokuj kafelki</button>
          <button id="clearTiles" class="btn alt">Usuń wszystkie kafelki</button>
        </div>
        <div class="field" style="margin-top:8px">
          <label>Auto-układ</label>
          <select id="autoLayout">
            <option value="fit">Dopasuj do siatki</option>
            <option value="cascade">Kaskada</option>
          </select>
        </div>
        <button id="applyLayout" class="btn small" style="margin-top:6px">Zastosuj</button>
      </div>

      <div class="panel flexcol">
        <h3>Backup/Restore (eksport/ import JSON)</h3>
        <div class="controls">
          <button id="exportAll" class="btn">Eksportuj całą bazę</button>
          <button id="exportUser" class="btn alt">Eksportuj aktywnego użytkownika</button>
        </div>
        <div class="field">
          <label>Import JSON</label>
          <textarea id="importBox" rows="4" placeholder='Wklej tu JSON bazy lub użytkownika'></textarea>
        </div>
        <div class="controls">
          <button id="importAll" class="btn">Importuj (nadpisuje)</button>
          <button id="importMerge" class="btn alt">Importuj i scal</button>
        </div>
        <div class="hint">Umożliwia przeniesienie danych między przeglądarkami/urządzeniami ręcznie.</div>
      </div>

      <div class="panel flexcol">
        <h3>Panel statystyk</h3>
        <div id="statsOnly" class="stats-only"></div>
        <div style="border-top:1px solid var(--border);padding-top:8px">
          <div class="badge">Podsumowanie portfela</div>
          <div id="sumStats" style="font-weight:700;margin-top:4px; white-space:nowrap; overflow:hidden; text-overflow:ellipsis">$0.00 | P/L $0.00 (0.00%)</div>
        </div>
      </div>
    </aside>

    <main style="display:flex;flex-direction:column;gap:18px">
      <section class="panel">
        <div class="kpis">
          <div class="kpi">
            <div class="label">Wartość portfela</div>
            <div class="value" id="kpiValue">$0.00</div>
            <div class="delta" id="kpiDelta">$0.00 (0.00%)</div>
          </div>
          <div class="kpi">
            <div class="label">Zysk/Strata dzienna</div>
            <div class="value" id="kpiDaily" class="good">$0.00</div>
            <div class="delta muted">symulacja</div>
          </div>
          <div class="kpi">
            <div class="label">Liczba pozycji</div>
            <div class="value" id="kpiPositions">0</div>
            <div class="delta muted">unikalne coiny</div>
          </div>
          <div class="kpi">
            <div class="label">Kafelki</div>
            <div class="value" id="kpiTiles">0</div>
            <div class="delta muted">wykresy na płótnie</div>
          </div>
        </div>
      </section>

      <section class="panel">
        <div class="tabs" id="tabs">
          <div class="tab active" data-tab="all">Wszystkie</div>
          <div class="tab" data-tab="manual">Ręczne</div>
          <div class="tab" data-tab="exchanges">Giełdy</div>
          <div class="tab" data-tab="wallets">Portfele</div>
        </div>

        <div class="two-col" style="align-items:start">
          <div style="overflow:auto">
            <h3>Pozycje</h3>
            <table class="table" id="positionsTable">
              <thead>
                <tr>
                  <th>Token</th>
                  <th>Ilość</th>
                  <th>Śr. cena</th>
                  <th>Aktualna</th>
                  <th>Wartość</th>
                  <th>P/L $</th>
                  <th>P/L %</th>
                  <th></th>
                </tr>
              </thead>
              <tbody></tbody>
              <tfoot>
                <tr><td colspan="8" class="muted" style="padding:10px">Brak danych. Dodaj pozycję lub wczytaj demo.</td></tr>
              </tfoot>
            </table>
          </div>

          <div style="min-width:420px">
            <h3>Płótno kafelków</h3>
            <div id="canvas" class="canvas"></div>
          </div>
        </div>
      </section>
    </main>
  </div>

  <footer>
    Aplikacja działa w 100% lokalnie (localStorage + sessionStorage). Wykresy i ceny są generowane proceduralnie, bez zewnętrznych API.
  </footer>

  <script type="module">
    import { v4 as uuidv4 } from "uuid";
    const ChartJS = window.Chart;

    // RNG and synthetic prices
    const seedRandom = (seed)=>{let t=seed;return ()=>{t+=0x6D2B79F5;let r=Math.imul(t^(t>>>15),1|t);r^=r+Math.imul(r^(r>>>7),61|r);return ((r^(r>>>14))>>>0)/4294967296}};
    const symbolToSeed = (sym)=>{let s=0;for(let i=0;i<sym.length;i++) s=(s*31+sym.charCodeAt(i))|0;return Math.abs(s)};
    const synthPrice = (symbol)=>{
      const baseSeed = symbolToSeed(symbol);
      const rnd = seedRandom(baseSeed + Math.floor(Date.now()/60000));
      const base = 10 + (baseSeed % 5000)/10;
      const vol = (baseSeed % 100)/100;
      const jitter = (rnd()*2-1)*base*0.03*(0.3+vol);
      return Math.max(0.0001, +(base + jitter).toFixed(4));
    };
    const synthSparkline = (symbol, points=120)=>{
      const baseSeed = symbolToSeed(symbol);
      const rnd = seedRandom(baseSeed);
      const base = 10 + (baseSeed % 5000)/10;
      let val = base;
      const out=[];
      for(let i=points-1;i>=0;i--){
        const noise = (rnd()*2-1) * base * 0.02;
        val = Math.max(0.0001, val + noise);
        out.push({ t: Date.now() - i*30000, v: +val.toFixed(4) });
      }
      return out;
    };

    // Local "DB"
    const dbKey = "kdash-v2";
    const defaultState = {
      users: [],
      sessions: [],
      profiles: {},
      portfolios: {},
      tiles: {}
    };
    const saveDB = (db)=> localStorage.setItem(dbKey, JSON.stringify(db));
    const loadDB = ()=> { try{ return JSON.parse(localStorage.getItem(dbKey)) || structuredClone(defaultState); }catch{ return structuredClone(defaultState);} };
    let DB = loadDB();

    const hash = (s)=>{let h=0;for(let i=0;i<s.length;i++){h=(h<<5)-h+s.charCodeAt(i);h|=0}return "h"+Math.abs(h)};

    const getSessionUser = ()=>{
      const token = sessionStorage.getItem("session");
      if(!token) return null;
      const s = DB.sessions.find(s=>s.token===token && s.exp>Date.now());
      if(!s) return null;
      return DB.users.find(u=>u.id===s.userId) || null;
    };
    const signUp = (email, password)=>{
      if(DB.users.some(u=>u.email===email)) throw new Error("Email już istnieje");
      const id = uuidv4();
      DB.users.push({ id, email, passHash: hash(password), createdAt: Date.now() });
      DB.profiles[id] = { displayName: email.split("@")[0], avatarColor: `hsl(${Math.abs(hash(email).length*37)%360} 70% 60%)` };
      DB.portfolios[id] = { manual: [], exchanges: [], wallets: [] };
      DB.tiles[id] = [];
      saveDB(DB);
      return id;
    };
    const login = (email,password)=>{
      const u = DB.users.find(u=>u.email===email && u.passHash===hash(password));
      if(!u) throw new Error("Nieprawidłowe dane logowania");
      const token = uuidv4();
      DB.sessions.push({ token, userId: u.id, exp: Date.now()+ 1000*60*60*24 });
      saveDB(DB);
      sessionStorage.setItem("session", token);
      return u;
    };
    const logout = ()=> sessionStorage.removeItem("session");

    const addManual = (uid, symbol, amount, avgPrice)=>{
      DB.portfolios[uid].manual.push({ id: uuidv4(), source: "manual", symbol: symbol.toUpperCase(), amount:+amount, avgPrice:+avgPrice });
      saveDB(DB);
    };
    const synthExchangePositions = (ex)=> {
      const syms = ["BTC","ETH","SOL","BNB","ARB","APT","SUI","XRP","POL","DOGE","ADA"];
      const rnd = seedRandom(symbolToSeed(ex.alias||"EX"));
      const n = 2 + Math.floor(rnd()*3);
      const out=[];
      for(let i=0;i<n;i++){
        const sym = syms[Math.floor(rnd()*syms.length)];
        const amount = +(rnd()*5).toFixed(4);
        const avgPrice = +(synthPrice(sym) * (0.8 + rnd()*0.4)).toFixed(4);
        out.push({ id: uuidv4(), source:"exchange", symbol:sym, amount, avgPrice, meta:{exchange:ex.alias} });
      }
      return out;
    };
    const synthWalletPositions = (w)=>{
      const chainMap = {"ethereum":"ETH","bnb":"BNB","arbitrum":"ARB","polygon":"POL","solana":"SOL","aptos":"APT","sui":"SUI","algorand":"ALGO","xrp":"XRP"};
      const sym = chainMap[(w.chain||"").toLowerCase()] || "ETH";
      const rnd = seedRandom(symbolToSeed(w.address||w.chain||"W"));
      const amount = +(rnd()*10).toFixed(4);
      const avgPrice = +(synthPrice(sym) * (0.7 + rnd()*0.6)).toFixed(4);
      return [{ id: uuidv4(), source:"wallet", symbol:sym, amount, avgPrice, meta:{chain:w.chain,address:w.address} }];
    };
    const addExchange = (uid, alias, key, secret)=>{
      DB.portfolios[uid].exchanges = DB.portfolios[uid].exchanges||[];
      DB.portfolios[uid].exchanges.push({ id: uuidv4(), alias, encKey:btoa(key||""), encSecret:btoa(secret||"") });
      saveDB(DB);
    };
    const addWallet = (uid, chain, address)=>{
      DB.portfolios[uid].wallets = DB.portfolios[uid].wallets||[];
      DB.portfolios[uid].wallets.push({ id: uuidv4(), chain, address });
      saveDB(DB);
    };

    const aggregate = (uid, scope="all")=>{
      const p = DB.portfolios[uid] || {manual:[],exchanges:[],wallets:[]};
      let positions = [];
      if(scope==="all" || scope==="manual") positions = positions.concat(p.manual);
      if(scope==="all" || scope==="exchanges") positions = positions.concat(p.exchanges.flatMap(synthExchangePositions));
      if(scope==="all" || scope==="wallets") positions = positions.concat(p.wallets.flatMap(synthWalletPositions));

      const map = new Map();
      for(const pos of positions){
        const m = map.get(pos.symbol) || {symbol:pos.symbol, amount:0, cost:0, sources:new Set(), items:[]};
        m.amount += pos.amount; m.cost += pos.amount*pos.avgPrice; m.sources.add(pos.source); m.items.push(pos);
        map.set(pos.symbol, m);
      }
      const rows=[]; let totalValue=0, totalCost=0;
      for(const [sym,m] of map){
        const price = synthPrice(sym);
        const avgPrice = m.amount>0 ? m.cost/m.amount : 0;
        const value = m.amount*price;
        const pl = value - m.cost;
        const plPct = avgPrice>0 ? (price/avgPrice - 1)*100 : 0;
        totalValue += value; totalCost += m.cost;
        rows.push({symbol:sym, amount:m.amount, avgPrice, price, value, pl, plPct, sources:[...m.sources]});
      }
      rows.sort((a,b)=>b.value-a.value);
      const plTotal = totalValue-totalCost;
      const plPct = totalCost>0 ? (totalValue/totalCost - 1)*100 : 0;
      return { rows, totals:{value:totalValue, pl:plTotal, plPct} };
    };

    const ui = {
      currentUser: document.getElementById("currentUser"),
      email: document.getElementById("email"),
      password: document.getElementById("password"),
      register: document.getElementById("register"),
      login: document.getElementById("login"),
      logout: document.getElementById("logout"),
      demoData: document.getElementById("demoData"),
      mSymbol: document.getElementById("mSymbol"),
      mAmount: document.getElementById("mAmount"),
      mAvgPrice: document.getElementById("mAvgPrice"),
      addManual: document.getElementById("addManual"),
      addTile: document.getElementById("addTile"),
      positionsTable: document.getElementById("positionsTable"),
      canvas: document.getElementById("canvas"),
      lockToggle: document.getElementById("lockToggle"),
      clearTiles: document.getElementById("clearTiles"),
      autoLayout: document.getElementById("autoLayout"),
      applyLayout: document.getElementById("applyLayout"),
      tabs: document.getElementById("tabs"),
      statsOnly: document.getElementById("statsOnly"),
      sumStats: document.getElementById("sumStats"),
      kpiValue: document.getElementById("kpiValue"),
      kpiDelta: document.getElementById("kpiDelta"),
      kpiDaily: document.getElementById("kpiDaily"),
      kpiPositions: document.getElementById("kpiPositions"),
      kpiTiles: document.getElementById("kpiTiles"),
      exportAll: document.getElementById("exportAll"),
      exportUser: document.getElementById("exportUser"),
      importBox: document.getElementById("importBox"),
      importAll: document.getElementById("importAll"),
      importMerge: document.getElementById("importMerge")
    };

    const fmtUSD = (v)=>"$"+(Math.abs(v)>=100000? v.toLocaleString(undefined,{maximumFractionDigits:0}) : v.toLocaleString(undefined,{maximumFractionDigits:2}));
    const col = (v)=> v>0?"good": v<0?"bad":"muted";

    const defaultTileSize = { w: 320, h: 200 };
    const getTiles = (uid)=> DB.tiles[uid] || [];
    const setTiles = (uid, tiles)=> { DB.tiles[uid]=tiles; saveDB(DB); };

    let activeTab = "all";
    let dragState = null;
    let resizeState = null;
    let isLocked = false;
    let charts = new Map();

    const destroyChart = (tileId)=>{
      const c = charts.get(tileId);
      if(c){ try{ c.destroy(); }catch{} charts.delete(tileId); }
    };

    const createTileEl = (tile, aggRow)=>{
      const el = document.createElement("div");
      el.className = "tile";
      if(isLocked || tile.locked) el.classList.add("locked");
      el.style.left = (tile.x||0)+"px";
      el.style.top = (tile.y||0)+"px";
      el.style.width = (tile.w||defaultTileSize.w)+"px";
      el.style.height = (tile.h||defaultTileSize.h)+"px";
      el.dataset.id = tile.id;

      const toolbar = document.createElement("div");
      toolbar.className = "toolbar";
      const title = document.createElement("div");
      title.className = "title";
      title.textContent = `${tile.symbol} — ${fmtUSD(aggRow?.price||synthPrice(tile.symbol))}`;
      const actions = document.createElement("div");
      actions.className = "actions";

      const btnAdd = document.createElement("button");
      btnAdd.className = "btn small alt";
      btnAdd.textContent = "+ duplikuj";
      btnAdd.addEventListener("click",(e)=>{ e.stopPropagation(); addTileForSymbol(tile.symbol); });

      const btnLock = document.createElement("button");
      btnLock.className = "btn small";
      btnLock.textContent = tile.locked? "Odblokuj" : "Zablokuj";
      btnLock.addEventListener("click",(e)=>{
        e.stopPropagation();
        toggleLockTile(tile.id);
      });

      const btnClose = document.createElement("button");
      btnClose.className = "btn small alt";
      btnClose.textContent = "Usuń";
      btnClose.addEventListener("click",(e)=>{ e.stopPropagation(); removeTile(tile.id); });

      actions.append(btnAdd, btnLock, btnClose);
      toolbar.append(title, actions);

      const content = document.createElement("div");
      content.className = "content";
      const canvas = document.createElement("canvas");
      content.appendChild(canvas);

      const stat = document.createElement("div");
      stat.className = "statline";
      const avg = aggRow?.avgPrice || 0;
      const price = aggRow?.price || synthPrice(tile.symbol);
      const pct = avg>0 ? ((price/avg-1)*100) : 0;
      stat.innerHTML = `
        <div><strong>${tile.symbol}</strong></div>
        <div class="badge">Śr. zakup: <strong>${fmtUSD(avg)}</strong></div>
        <div class="badge">Aktualna: <strong>${fmtUSD(price)}</strong></div>
        <div class="badge ${col(pct)}">Zmiana: <strong>${(pct>=0?"+":"") + pct.toFixed(2)}%</strong></div>
        <div></div>
      `;

      const res = document.createElement("div");
      res.className = "resizer";

      el.append(toolbar, content, res, stat);

      if(!(isLocked || tile.locked)){
        toolbar.addEventListener("pointerdown",(e)=>{
          const id = tile.id;
          el.setPointerCapture(e.pointerId);
          dragState = { id, startX:e.clientX, startY:e.clientY, origX: tile.x||0, origY: tile.y||0 };
        });
        el.addEventListener("pointermove",(e)=>{
          if(!dragState || dragState.id!==tile.id) return;
          const dx = e.clientX - dragState.startX;
          const dy = e.clientY - dragState.startY;
          const nx = Math.max(0, dragState.origX + dx);
          const ny = Math.max(0, dragState.origY + dy);
          el.style.left = nx+"px";
          el.style.top = ny+"px";
        });
        el.addEventListener("pointerup",(e)=>{
          if(dragState && dragState.id===tile.id){
            const cu = getSessionUser(); if(!cu) return;
            const tiles = getTiles(cu.id).map(t=> t.id===tile.id ? {...t, x: parseInt(el.style.left), y: parseInt(el.style.top)} : t);
            setTiles(cu.id, tiles);
          }
          dragState=null;
        });

        res.addEventListener("pointerdown",(e)=>{
          e.stopPropagation();
          el.setPointerCapture(e.pointerId);
          resizeState = { id: tile.id, startX: e.clientX, startY: e.clientY, origW: tile.w||defaultTileSize.w, origH: tile.h||defaultTileSize.h };
        });
        el.addEventListener("pointermove",(e)=>{
          if(!resizeState || resizeState.id!==tile.id) return;
          const dw = e.clientX - resizeState.startX;
          const dh = e.clientY - resizeState.startY;
          const nw = Math.max(220, resizeState.origW + dw);
          const nh = Math.max(160, resizeState.origH + dh);
          el.style.width = nw+"px";
          el.style.height = nh+"px";
          const chart = charts.get(tile.id);
          if(chart){ chart.resize(); }
        });
        el.addEventListener("pointerup",()=>{
          if(resizeState && resizeState.id===tile.id){
            const cu = getSessionUser(); if(!cu) return;
            const tiles = getTiles(cu.id).map(t=> t.id===tile.id ? {...t, w: parseInt(el.style.width), h: parseInt(el.style.height)} : t);
            setTiles(cu.id, tiles);
          }
          resizeState=null;
        });
      }

      const data = synthSparkline(tile.symbol, 120);
      const labels = data.map(d=> new Date(d.t));
      const values = data.map(d=> d.v);
      const ctx = canvas.getContext("2d");
      const grad = ctx.createLinearGradient(0,0,0,200);
      grad.addColorStop(0, "rgba(106,169,255,0.35)");
      grad.addColorStop(1, "rgba(106,169,255,0.02)");
      const chart = new ChartJS(canvas, {
        type:"line",
        data:{ labels, datasets:[{ label: tile.symbol, data: values, fill:true, borderColor:"#6aa9ff", backgroundColor:grad, tension:0.3, pointRadius:0 }] },
        options:{
          plugins:{ legend:{display:false} },
          scales:{ x:{display:false}, y:{display:false} },
          animation:false,
          responsive:true,
          maintainAspectRatio:false
        }
      });
      charts.set(tile.id, chart);

      return el;
    };

    const renderTiles = ()=>{
      const u = getSessionUser(); if(!u){ document.getElementById("canvas").innerHTML=""; return; }
      document.getElementById("canvas").innerHTML = "";
      const agg = aggregate(u.id, activeTab);
      const rowsBySym = Object.fromEntries(agg.rows.map(r=>[r.symbol, r]));
      const tiles = getTiles(u.id);
      tiles.forEach(tile=>{
        const el = createTileEl(tile, rowsBySym[tile.symbol]);
        document.getElementById("canvas").appendChild(el);
      });
      ui.kpiTiles.textContent = tiles.length;
    };

    const addTileForSymbol = (symbol)=>{
      const u = getSessionUser(); if(!u) return alert("Zaloguj się.");
      const tiles = getTiles(u.id);
      const x = 20 + (tiles.length%3)* (defaultTileSize.w + 16);
      const y = 20 + Math.floor(tiles.length/3) * (defaultTileSize.h + 16);
      tiles.push({ id: uuidv4(), symbol: symbol.toUpperCase(), x, y, w: defaultTileSize.w, h: defaultTileSize.h, locked: false });
      setTiles(u.id, tiles);
      renderTiles();
    };
    const removeTile = (id)=>{
      const u = getSessionUser(); if(!u) return;
      destroyChart(id);
      const tiles = getTiles(u.id).filter(t=>t.id!==id);
      setTiles(u.id, tiles);
      renderTiles();
    };
    const toggleLockAll = ()=>{
      const u = getSessionUser(); if(!u) return;
      isLocked = !isLocked;
      const tiles = getTiles(u.id).map(t=> ({...t, locked: isLocked}));
      setTiles(u.id, tiles);
      ui.lockToggle.textContent = isLocked? "Odblokuj kafelki" : "Zablokuj kafelki";
      renderTiles();
    };
    const toggleLockTile = (id)=>{
      const u = getSessionUser(); if(!u) return;
      const tiles = getTiles(u.id).map(t=> t.id===id ? ({...t, locked: !t.locked}) : t);
      setTiles(u.id, tiles);
      renderTiles();
    };

    const autoLayoutTiles = (mode="fit")=>{
      const u = getSessionUser(); if(!u) return;
      const tiles = getTiles(u.id);
      const W = ui.canvas.clientWidth || 800;
      const gap = 16;
      const colW = defaultTileSize.w, rowH = defaultTileSize.h;
      let x=gap, y=gap, maxH=rowH;

      tiles.forEach((t, idx)=>{
        if(mode==="fit"){
          if(x + colW + gap > W){ x=gap; y+= maxH + gap; maxH = rowH; }
          t.x = x; t.y = y; t.w = colW; t.h = rowH;
          x += colW + gap;
        }else{
          t.x = gap + (idx*24)%Math.max(24, (W - colW - gap));
          t.y = gap + idx*28;
          t.w = colW; t.h = rowH;
        }
      });
      setTiles(u.id, tiles);
      renderTiles();
    };

    const renderTable = (rows)=>{
      const tbody = ui.positionsTable.querySelector("tbody");
      const tfoot = ui.positionsTable.querySelector("tfoot");
      tbody.innerHTML = "";
      if(rows.length===0){ tfoot.style.display=""; return; }
      tfoot.style.display="none";
      for(const r of rows){
        const tr = document.createElement("tr");
        tr.innerHTML = `
          <td><strong>${r.symbol}</strong> <span class="muted" style="font-size:11px">[${r.sources.join(", ")}]</span></td>
          <td>${r.amount.toFixed(6)}</td>
          <td>${fmtUSD(r.avgPrice)}</td>
          <td>${fmtUSD(r.price)}</td>
          <td>${fmtUSD(r.value)}</td>
          <td class="${col(r.pl)}">${(r.pl>=0?"+":"") + fmtUSD(r.pl)}</td>
          <td class="${col(r.plPct)}">${(r.plPct>=0?"+":"") + r.plPct.toFixed(2)}%</td>
          <td><button class="btn small alt" data-add="${r.symbol}">Kafelek</button></td>
        `;
        tbody.appendChild(tr);
      }
      tbody.querySelectorAll("button[data-add]").forEach(b=>{
        b.addEventListener("click", ()=> addTileForSymbol(b.dataset.add));
      });
    };

    const renderStatsPanel = (rows, totals)=>{
      ui.statsOnly.innerHTML = "";
      for(const r of rows){
        const row = document.createElement("div");
        row.className = "mini-row";
        row.innerHTML = `
          <div class="cell"><span class="label">Token</span><span class="value"><strong>${r.symbol}</strong></span></div>
          <div class="cell"><span class="label">Ilość</span><span class="value"><strong>${r.amount.toFixed(6)}</strong></span></div>
          <div class="cell"><span class="label">Śr. cena</span><span class="value"><strong>${fmtUSD(r.avgPrice)}</strong></span></div>
          <div class="cell"><span class="label">Aktualna</span><span class="value"><strong>${fmtUSD(r.price)}</strong></span></div>
          <div class="cell"><span class="label">Wartość</span><span class="value"><strong>${fmtUSD(r.value)}</strong></span></div>
          <div class="cell"><span class="label">P/L %</span><span class="value ${col(r.plPct)}"><strong>${(r.plPct>=0?"+":"") + r.plPct.toFixed(2)}%</strong></span></div>
        `;
        ui.statsOnly.appendChild(row);
      }
      ui.sumStats.textContent = `${fmtUSD(totals.value)} | P/L ${(totals.pl>=0?"+":"") + fmtUSD(totals.pl)} (${totals.plPct.toFixed(2)}%)`;
    };

    const renderKPIs = (agg)=>{
      ui.kpiValue.textContent = fmtUSD(agg.totals.value);
      ui.kpiDelta.textContent = `${fmtUSD(agg.totals.pl)} (${agg.totals.plPct.toFixed(2)}%)`;
      ui.kpiDelta.className = "delta " + col(agg.totals.pl);
      const daily = agg.totals.value * (Math.sin(Date.now()/1000/60) * 0.005);
      ui.kpiDaily.textContent = (daily>=0?"+":"") + fmtUSD(daily);
      ui.kpiDaily.className = "value " + col(daily);
      ui.kpiPositions.textContent = agg.rows.length;
    };

    ui.tabs.addEventListener("click",(e)=>{
      const el = e.target.closest(".tab");
      if(!el) return;
      document.querySelectorAll(".tab").forEach(t=>t.classList.toggle("active", t===el));
      activeTab = el.dataset.tab;
      update();
    });

    const refreshUser = ()=>{
      const u = getSessionUser();
      if(u){
        const p = DB.profiles[u.id];
        ui.currentUser.textContent = p?.displayName || u.email;
        ui.currentUser.style.background = p ? p.avatarColor : "";
      }else{
        ui.currentUser.textContent="Gość";
        ui.currentUser.style.background="";
      }
    };

    const download = (filename, text)=>{
      const a = document.createElement("a");
      a.href = URL.createObjectURL(new Blob([text],{type:"application/json"}));
      a.download = filename;
      a.click();
      setTimeout(()=> URL.revokeObjectURL(a.href), 1000);
    };
    ui.exportAll.addEventListener("click", ()=>{
      download("kdash-export-all.json", JSON.stringify(DB, null, 2));
    });
    ui.exportUser.addEventListener("click", ()=>{
      const u = getSessionUser(); if(!u) return alert("Zaloguj się.");
      const pack = {
        users:[DB.users.find(x=>x.id===u.id)],
        profiles:{ [u.id]: DB.profiles[u.id] },
        portfolios:{ [u.id]: DB.portfolios[u.id] },
        tiles:{ [u.id]: DB.tiles[u.id] }
      };
      download(`kdash-user-${u.id}.json`, JSON.stringify(pack, null, 2));
    });
    ui.importAll.addEventListener("click", ()=>{
      try{
        const parsed = JSON.parse(ui.importBox.value);
        if(!parsed || typeof parsed!=="object") throw new Error("Niepoprawny JSON");
        DB = Object.assign(structuredClone(defaultState), parsed);
        saveDB(DB);
        sessionStorage.removeItem("session");
        alert("Zaimportowano całą bazę. Zaloguj się ponownie.");
        refreshUser(); update();
      }catch(e){ alert("Błąd importu: "+e.message); }
    });
    ui.importMerge.addEventListener("click", ()=>{
      try{
        const pack = JSON.parse(ui.importBox.value);
        if(!pack || typeof pack!=="object") throw new Error("Niepoprawny JSON");
        (pack.users||[]).forEach(nu=>{
          const exists = DB.users.find(u=>u.email===nu.email);
          if(!exists){
            DB.users.push(nu);
            if(pack.profiles?.[nu.id]) DB.profiles[nu.id]=pack.profiles[nu.id];
            if(pack.portfolios?.[nu.id]) DB.portfolios[nu.id]=pack.portfolios[nu.id];
            if(pack.tiles?.[nu.id]) DB.tiles[nu.id]=pack.tiles[nu.id];
          }
        });
        saveDB(DB);
        alert("Zaimportowano i scalono. Zaloguj się na odpowiednie konto.");
        refreshUser(); update();
      }catch(e){ alert("Błąd importu: "+e.message); }
    });

    ui.register.addEventListener("click", ()=>{
      try{
        const email = ui.email.value.trim(), pass = ui.password.value;
        if(!email || !pass) throw new Error("Podaj email i hasło.");
        signUp(email, pass); login(email, pass); refreshUser(); update();
        alert("Utworzono konto (lokalnie) i zalogowano.");
      }catch(e){ alert(e.message); }
    });
    ui.login.addEventListener("click", ()=>{
      try{ login(ui.email.value.trim(), ui.password.value); refreshUser(); update(); }
      catch(e){ alert(e.message); }
    });
    ui.logout.addEventListener("click", ()=>{ logout(); refreshUser(); update(); });

    ui.addManual.addEventListener("click", ()=>{
      const u = getSessionUser(); if(!u) return alert("Zaloguj się.");
      const sym = ui.mSymbol.value.trim().toUpperCase();
      const amt = parseFloat(ui.mAmount.value);
      const ap = parseFloat(ui.mAvgPrice.value);
      if(!sym || !(amt>0) || !(ap>0)) return alert("Podaj poprawne wartości.");
      addManual(u.id, sym, amt, ap);
      ui.mSymbol.value=""; ui.mAmount.value=""; ui.mAvgPrice.value="";
      update();
    });

    ui.addTile.addEventListener("click", ()=>{
      const sym = (ui.mSymbol.value.trim().toUpperCase()) || "BTC";
      addTileForSymbol(sym);
    });

    ui.lockToggle.addEventListener("click", ()=> toggleLockAll());
    ui.clearTiles.addEventListener("click", ()=>{
      const u = getSessionUser(); if(!u) return;
      getTiles(u.id).forEach(t=> destroyChart(t.id));
      setTiles(u.id, []);
      renderTiles();
    });
    ui.applyLayout.addEventListener("click", ()=> autoLayoutTiles(ui.autoLayout.value));

    document.getElementById("positionsTable").addEventListener("dblclick",(e)=>{
      const td = e.target.closest("td"); if(!td) return;
      const tr = td.parentElement;
      const symCell = tr?.children?.[0];
      if(!symCell) return;
      const sym = symCell.textContent.trim().split(" ")[0];
      if(sym) addTileForSymbol(sym);
    });

    document.getElementById("demoData").addEventListener("click", ()=>{
      try{
        let u = DB.users.find(x=>x.email==="demo@user.local");
        if(!u){
          signUp("demo@user.local","demo1234");
          u = DB.users.find(x=>x.email==="demo@user.local");
          addManual(u.id,"BTC",0.25,30000);
          addManual(u.id,"ETH",1.5,2000);
          addManual(u.id,"SOL",10,20);
          addExchange(u.id,"Binance DEMO","key","secret");
          addWallet(u.id,"Solana","DEMO-SOL");
          setTiles(u.id, [
            {id:uuidv4(), symbol:"BTC", x:16, y:16, w:360, h:220, locked:false},
            {id:uuidv4(), symbol:"ETH", x:396, y:16, w:360, h:220, locked:false},
            {id:uuidv4(), symbol:"SOL", x:16, y:252, w:360, h:220, locked:false}
          ]);
        }
        login("demo@user.local","demo1234");
        refreshUser();
        update();
        alert("Załadowano dane demo i zalogowano.");
      }catch(e){ alert(e.message); }
    });

    const update = ()=>{
      const u = getSessionUser();
      refreshUser();
      if(!u){
        renderTable([]);
        ui.statsOnly.innerHTML = "";
        ui.sumStats.textContent = "$0.00 | P/L $0.00 (0.00%)";
        ui.kpiValue.textContent = "$0.00";
        ui.kpiDelta.textContent = "$0.00 (0.00%)";
        ui.kpiDaily.textContent = "$0.00";
        ui.kpiPositions.textContent = "0";
        ui.kpiTiles.textContent = "0";
        ui.canvas.innerHTML = "";
        charts.forEach((c,id)=> destroyChart(id));
        charts.clear();
        return;
      }
      const agg = aggregate(u.id, activeTab);
      renderKPIs(agg);
      renderTable(agg.rows);
      renderStatsPanel(agg.rows, agg.totals);
      renderTiles();
    };

    setInterval(()=> update(), 12000);

    refreshUser();
    update();
  </script>
</body>
</html>
